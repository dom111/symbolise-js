(function(sym__g_window_, sym__g_null_, sym__g_false_, sym__g_true_, sym__PSEUDO_, sym__fx_, sym__form_, sym__pixelPosition_, sym__deletedIds_, sym__cssText_, sym__makeArray_, sym__pseudos_, sym__domManip_, sym__resolveWith_, sym__unique_, sym__extend_, sym__fail_, sym__contentWindow_, sym__pageXOffset_, sym__dispatch_, sym__inprogress_, sym__dataTypes_, sym__isPropagationStopped_, sym__ajaxTransport_, sym__toggle_, sym__nextSibling_, sym__htmlSerialize_, sym__traditional_, sym__crossDomain_, sym__mimeType_, sym__removeAttr_, sym__fixHooks_, sym__offsetHeight_, sym__dir_, sym__doesNotIncludeMarginInBodyOffset_, sym__unqueued_, sym__overflow_, sym__reliableMarginRight_, sym__expando_, sym__access_, sym__concat_, sym__getElementsByTagName_, sym__removeEvent_, sym__delegateTarget_, sym__prop_, sym__ifModified_, sym__beforeSend_, sym__left_, sym__remove_, sym__substr_, sym__display_, sym__jQuery_, sym__grep_, sym__cssFloat_, sym__accepts_, sym__toLowerCase_, sym__id_, sym__cleanData_, sym__runtimeStyle_, sym__abort_, sym__currentStyle_, sym__data_, sym__setFilters_, sym__contains_, sym__jquery_, sym__overrideMimeType_, sym__props_, sym__shift_, sym__olddisplay_, sym__type_, sym__support_, sym__div_, sym__object_, sym__previousSibling_, sym__trigger_, sym__scrollTop_, sym__add_, sym__buildFragment_, sym__bindType_, sym__status_, sym__needsContext_, sym__submit_, sym__sizset_, sym__overflowY_, sym__lastChild_, sym__get_, sym__parsedAttrs_, sym__context_, sym__guid_, sym__option_, sym__leadingWhitespace_, sym__global_, sym__prevObject_, sym__isTrigger_, sym__border_, sym__parseJSON_, sym__auto_, sym__removeClass_, sym__relatedTarget_, sym__cssProps_, sym__fireWith_, sym__nodeName_, sym__complete_, sym__delegateType_, sym__attrHooks_, sym__content_, sym__string_, sym__filters_, sym__getBoundingClientRect_, sym__on_, sym__map_, sym__childNodes_, sym__timeout_, sym__marginRight_, sym__deleteExpando_, sym__change_, sym__marginTop_, sym__triggerHandler_, sym__selectors_, sym__handle_, sym__top_, sym__queue_, sym__inlineBlockNeedsLayout_, sym__insertBefore_, sym__width_, sym__preDispatch_, sym__number_, sym__isFunction_, sym__body_, sym__html_, sym__fragments_, sym__error_, sym__ActiveXObject_, sym__clearAttributes_, sym__disable_, sym__isWindow_, sym__matches_, sym__namespace_, sym__constructor_, sym__fireEvent_, sym__style_, sym__triggered_, sym__ajax_, sym__now_, sym__radioValue_, sym__onbeforeunload_, sym__shrinkWrapBlocks_, sym__indexOf_, sym__cache_, sym__getElementById_, sym__XMLHttpRequest_, sym__postDispatch_, sym__checkbox_, sym__test_, sym__document_, sym__CHILD_, sym__isEmptyObject_, sym__parentNode_, sym__pageYOffset_, sym__isPlainObject_, sym__step_, sym__propFix_, sym__clone_, sym__scriptCharset_, sym__prototype_, sym__param_, sym__exec_, sym__show_, sym__createElement_, sym__clientLeft_, sym__specialEasing_, sym__duration_, sym__boxSizingReliable_, sym__statusText_, sym__event_, sym__lastToggle_, sym__DOMContentLoaded_, sym__valHooks_, sym__globalEval_, sym__createTween_, sym__timeStamp_, sym__append_, sym__jsonpCallback_, sym__getElementsByClassName_, sym__expr_, sym__call_, sym__checkClone_, sym__getPreventDefault_, sym__speeds_, sym__Callbacks_, sym__handler_, sym__querySelectorAll_, sym__mergeAttributes_, sym__selected_, sym__replaceWith_, sym__acceptData_, sym__which_, sym__returnValue_, sym__camelCase_, sym__init_, sym__target_, sym__queueHooks_, sym__password_, sym__propHooks_, sym__notifyWith_, sym__opts_, sym__easing_, sym__always_, sym__relative_, sym__each_, sym__trim_, sym__Deferred_, sym__name_, sym__className_, sym__nodeValue_, sym__specified_, sym__hide_, sym__promise_, sym__start_, sym__cacheable_, sym__css_, sym__getAttribute_, sym__enctype_, sym__outerHTML_, sym__delegateCount_, sym__boolean_, sym__opacity_, sym__uniqueSort_, sym__maxWidth_, sym__selectedIndex_, sym__unshift_, sym__cloneNode_, sym__appendChecked_, sym__removeAttribute_, sym__CLASS_, sym__isImmediatePropagationStopped_, sym__appendChild_, sym__progress_, sym__boxSizing_, sym__height_, sym__getElementsByName_, sym__isXMLDoc_, sym__index_, sym__click_, sym__length_, sym__sort_, sym__events_, sym__ownerDocument_, sym__sourceIndex_, sym__defaultView_, sym__false_, sym__ajaxSettings_, sym__async_, sym__off_, sym__noCloneEvent_, sym__slice_, sym__jsonp_, sym__special_, sym__activeElement_, sym__href_, sym__addEventListener_, sym__animate_, sym__origType_, sym__exclusive_, sym__split_, sym__changeData_, sym__removeChild_, sym__selector_, sym__tbody_, sym__xhrFields_, sym__value_, sym__active_, sym__dataFilter_, sym__hasOwnProperty_, sym__replace_, sym__push_, sym__setAttribute_, sym__rejectWith_, sym__ready_, sym__defaultValue_, sym__offsetParent_, sym__readyWait_, sym__stopPropagation_, sym__isSimulated_, sym__position_, sym__readyState_, sym__pushStack_, sym__optDisabled_, sym__fxshow_, sym__isReady_, sym__noCloneChecked_, sym__isArray_, sym__reliableHiddenOffsets_, sym__fire_, sym__parentWindow_, sym__fn_, sym__contentType_, sym__Event_, sym__zoom_, sym__cssNumber_, sym__contentDocument_, sym__splice_, sym__ajaxSetup_, sym__block_, sym__hidden_, sym__button_, sym__reject_, sym__input_, sym__attachEvent_, sym__handleObj_, sym__charAt_, sym__isNumeric_, sym__responseXML_, sym__removeData_, sym__toUpperCase_, sym__offsetTop_, sym__url_, sym__preventDefault_, sym__innerHTML_, sym__parsererror_, sym__setRequestHeader_, sym__responseText_, sym__join_, sym__onclick_, sym__attributes_, sym__wrapAll_, sym__getComputedStyle_, sym__result_, sym__none_, sym__options_, sym__function_, sym__textContent_, sym__find_, sym__attr_, sym__statusCode_, sym__clientTop_, sym__text_, sym__converters_, sym__set_, sym__padding_, sym__getAttributeNode_, sym__filter_, sym__cssHooks_, sym__documentElement_, sym__radio_, sym__dequeue_, sym__simulate_, sym__html5Clone_, sym__firstChild_, sym__elem_, sym__done_, sym__ajaxPrefilter_, sym__scrollLeft_, sym__browser_, sym__matchesSelector_, sym__marginLeft_, sym__undefined_, sym__before_, sym__timers_, sym__hasContent_, sym__success_, sym__clean_, sym__removeEventListener_, sym__checked_, sym__compareDocumentPosition_, sym__lastModified_, sym__px_, sym__onreadystatechange_, sym__nodeType_, sym__disabled_, sym__minWidth_, sym__fragment_, sym__Width_, sym__apply_, sym__merge_, sym__tweens_, sym__empty_, sym__offset_, sym__isDefaultPrevented_, sym__first_, sym__script_, sym__stop_, sym__defaultChecked_, sym__offsetWidth_, sym__createDocumentFragment_, sym__getResponseHeader_, sym__inArray_, sym__detachEvent_, sym__overflowX_, sym__originalEvent_, sym__createTextNode_, sym__onload_, sym__margin_){/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function( sym__g_window_, undefined ) {
var
    // A central reference to the root jQuery(document)
    rootjQuery,

    // The deferred used on DOM ready
    readyList,

    // Use the correct document accordingly with window argument (sandbox)
    document = sym__g_window_[sym__document_],
    location = sym__g_window_.location,
    navigator = sym__g_window_.navigator,

    // Map over jQuery in case of overwrite
    _jQuery = sym__g_window_[sym__jQuery_],

    // Map over the $ in case of overwrite
    _$ = sym__g_window_.$,

    // Save a reference to some core methods
    core_push = Array[sym__prototype_][sym__push_],
    core_slice = Array[sym__prototype_][sym__slice_],
    core_indexOf = Array[sym__prototype_][sym__indexOf_],
    core_toString = Object[sym__prototype_].toString,
    core_hasOwn = Object[sym__prototype_][sym__hasOwnProperty_],
    core_trim = String[sym__prototype_][sym__trim_],

    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor 'enhanced'
        return new jQuery[sym__fn_][sym__init_]( selector, context, rootjQuery );
    },

    // Used for matching numbers
    core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

    // Used for detecting and trimming whitespace
    core_rnotwhite = /\S/,
    core_rspace = /\s+/,

    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

    // Match a standalone tag
    rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

    // JSON RegExp
    rvalidchars = /^[\],:{}\s]*$/,
    rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
    rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
    rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function( all, letter ) {
        return ( letter + "" )[sym__toUpperCase_]();
    },

    // The ready event handler and self cleanup method
    DOMContentLoaded = function() {
        if ( document[sym__addEventListener_] ) {
            document[sym__removeEventListener_]( sym__DOMContentLoaded_, DOMContentLoaded, sym__g_false_ );
            jQuery[sym__ready_]();
        } else if ( document[sym__readyState_] === sym__complete_ ) {
            // we're here because readyState === "complete" in oldIE
            // which is good enough for us to call the dom ready!
            document[sym__detachEvent_]( sym__onreadystatechange_, DOMContentLoaded );
            jQuery[sym__ready_]();
        }
    },

    // [[Class]] -> type pairs
    class2type = {};

jQuery[sym__fn_] = jQuery[sym__prototype_] = {
    constructor: jQuery,
    init: function( selector, context, rootjQuery ) {
        var match, elem, ret, doc;

        // Handle $(""), $(null), $(undefined), $(false)
        if ( !selector ) {
            return this;
        }

        // Handle $(DOMElement)
        if ( selector[sym__nodeType_] ) {
            this[sym__context_] = this[0] = selector;
            this[sym__length_] = 1;
            return this;
        }

        // Handle HTML strings
        if ( typeof selector === sym__string_ ) {
            if ( selector[sym__charAt_](0) === "<" && selector[sym__charAt_]( selector[sym__length_] - 1 ) === ">" && selector[sym__length_] >= 3 ) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ sym__g_null_, selector, sym__g_null_ ];

            } else {
                match = rquickExpr[sym__exec_]( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && (match[1] || !context) ) {

                // HANDLE: $(html) -> $(array)
                if ( match[1] ) {
                    context = context instanceof jQuery ? context[0] : context;
                    doc = ( context && context[sym__nodeType_] ? context[sym__ownerDocument_] || context : document );

                    // scripts is true for back-compat
                    selector = jQuery.parseHTML( match[1], doc, sym__g_true_ );
                    if ( rsingleTag[sym__test_]( match[1] ) && jQuery[sym__isPlainObject_]( context ) ) {
                        this[sym__attr_][sym__call_]( selector, context, sym__g_true_ );
                    }

                    return jQuery[sym__merge_]( this, selector );

                // HANDLE: $(#id)
                } else {
                    elem = document[sym__getElementById_]( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem[sym__parentNode_] ) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if ( elem[sym__id_] !== match[2] ) {
                            return rootjQuery[sym__find_]( selector );
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this[sym__length_] = 1;
                        this[0] = elem;
                    }

                    this[sym__context_] = document;
                    this[sym__selector_] = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context[sym__jquery_] ) {
                return ( context || rootjQuery )[sym__find_]( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
                return this[sym__constructor_]( context )[sym__find_]( selector );
            }

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery[sym__isFunction_]( selector ) ) {
            return rootjQuery[sym__ready_]( selector );
        }

        if ( selector[sym__selector_] !== undefined ) {
            this[sym__selector_] = selector[sym__selector_];
            this[sym__context_] = selector[sym__context_];
        }

        return jQuery[sym__makeArray_]( selector, this );
    },

    // Start with an empty selector
    selector: "",

    // The current version of jQuery being used
    jquery: "1.8.3",

    // The default length of a jQuery object is 0
    length: 0,

    // The number of elements contained in the matched element set
    size: function() {
        return this[sym__length_];
    },

    toArray: function() {
        return core_slice[sym__call_]( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
        return num == sym__g_null_ ?

            // Return a 'clean' array
            this.toArray() :

            // Return just the object
            ( num < 0 ? this[ this[sym__length_] + num ] : this[ num ] );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems, name, selector ) {

        // Build a new jQuery matched element set
        var ret = jQuery[sym__merge_]( this[sym__constructor_](), elems );

        // Add the old object onto the stack (as a reference)
        ret[sym__prevObject_] = this;

        ret[sym__context_] = this[sym__context_];

        if ( name === sym__find_ ) {
            ret[sym__selector_] = this[sym__selector_] + ( this[sym__selector_] ? " " : "" ) + selector;
        } else if ( name ) {
            ret[sym__selector_] = this[sym__selector_] + "." + name + "(" + selector + ")";
        }

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery[sym__each_]( this, callback, args );
    },

    ready: function( fn ) {
        // Add the callback
        jQuery[sym__ready_][sym__promise_]()[sym__done_]( fn );

        return this;
    },

    eq: function( i ) {
        i = +i;
        return i === -1 ?
            this[sym__slice_]( i ) :
            this[sym__slice_]( i, i + 1 );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    slice: function() {
        return this[sym__pushStack_]( core_slice[sym__apply_]( this, arguments ),
            sym__slice_, core_slice[sym__call_](arguments)[sym__join_](",") );
    },

    map: function( callback ) {
        return this[sym__pushStack_]( jQuery[sym__map_](this, function( elem, i ) {
            return callback[sym__call_]( elem, i, elem );
        }));
    },

    end: function() {
        return this[sym__prevObject_] || this[sym__constructor_](sym__g_null_);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: core_push,
    sort: [][sym__sort_],
    splice: [][sym__splice_]
};

// Give the init function the jQuery prototype for later instantiation
jQuery[sym__fn_][sym__init_][sym__prototype_] = jQuery[sym__fn_];

jQuery[sym__extend_] = jQuery[sym__fn_][sym__extend_] = function() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments[sym__length_],
        deep = sym__g_false_;

    // Handle a deep copy situation
    if ( typeof target === sym__boolean_ ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== sym__object_ && !jQuery[sym__isFunction_](target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( length === i ) {
        target = this;
        --i;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != sym__g_null_ ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery[sym__isPlainObject_](copy) || (copyIsArray = jQuery[sym__isArray_](copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = sym__g_false_;
                        clone = src && jQuery[sym__isArray_](src) ? src : [];

                    } else {
                        clone = src && jQuery[sym__isPlainObject_](src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery[sym__extend_]( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

jQuery[sym__extend_]({
    noConflict: function( deep ) {
        if ( sym__g_window_.$ === jQuery ) {
            sym__g_window_.$ = _$;
        }

        if ( deep && sym__g_window_[sym__jQuery_] === jQuery ) {
            sym__g_window_[sym__jQuery_] = _jQuery;
        }

        return jQuery;
    },

    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: sym__g_false_,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function( hold ) {
        if ( hold ) {
            jQuery[sym__readyWait_]++;
        } else {
            jQuery[sym__ready_]( sym__g_true_ );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {

        // Abort if there are pending holds or we're already ready
        if ( wait === sym__g_true_ ? --jQuery[sym__readyWait_] : jQuery[sym__isReady_] ) {
            return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document[sym__body_] ) {
            return setTimeout( jQuery[sym__ready_], 1 );
        }

        // Remember that the DOM is ready
        jQuery[sym__isReady_] = sym__g_true_;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== sym__g_true_ && --jQuery[sym__readyWait_] > 0 ) {
            return;
        }

        // If there are functions bound, to execute
        readyList[sym__resolveWith_]( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery[sym__fn_][sym__trigger_] ) {
            jQuery( document )[sym__trigger_](sym__ready_)[sym__off_](sym__ready_);
        }
    },

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function( obj ) {
        return jQuery[sym__type_](obj) === sym__function_;
    },

    isArray: Array[sym__isArray_] || function( obj ) {
        return jQuery[sym__type_](obj) === "array";
    },

    isWindow: function( obj ) {
        return obj != sym__g_null_ && obj == obj.sym__g_window_;
    },

    isNumeric: function( obj ) {
        return !isNaN( parseFloat(obj) ) && isFinite( obj );
    },

    type: function( obj ) {
        return obj == sym__g_null_ ?
            String( obj ) :
            class2type[ core_toString[sym__call_](obj) ] || sym__object_;
    },

    isPlainObject: function( obj ) {
        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if ( !obj || jQuery[sym__type_](obj) !== sym__object_ || obj[sym__nodeType_] || jQuery[sym__isWindow_]( obj ) ) {
            return sym__g_false_;
        }

        try {
            // Not own constructor property must be Object
            if ( obj[sym__constructor_] &&
                !core_hasOwn[sym__call_](obj, sym__constructor_) &&
                !core_hasOwn[sym__call_](obj[sym__constructor_][sym__prototype_], "isPrototypeOf") ) {
                return sym__g_false_;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return sym__g_false_;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.

        var key;
        for ( key in obj ) {}

        return key === undefined || core_hasOwn[sym__call_]( obj, key );
    },

    isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
            return sym__g_false_;
        }
        return sym__g_true_;
    },

    error: function( msg ) {
        throw new Error( msg );
    },

    // data: string of html
    // context (optional): If specified, the fragment will be created in this context, defaults to document
    // scripts (optional): If true, will include scripts passed in the html string
    parseHTML: function( data, context, scripts ) {
        var parsed;
        if ( !data || typeof data !== sym__string_ ) {
            return sym__g_null_;
        }
        if ( typeof context === sym__boolean_ ) {
            scripts = context;
            context = 0;
        }
        context = context || document;

        // Single tag
        if ( (parsed = rsingleTag[sym__exec_]( data )) ) {
            return [ context[sym__createElement_]( parsed[1] ) ];
        }

        parsed = jQuery[sym__buildFragment_]( [ data ], context, scripts ? sym__g_null_ : [] );
        return jQuery[sym__merge_]( [],
            (parsed[sym__cacheable_] ? jQuery[sym__clone_]( parsed[sym__fragment_] ) : parsed[sym__fragment_])[sym__childNodes_] );
    },

    parseJSON: function( data ) {
        if ( !data || typeof data !== sym__string_) {
            return sym__g_null_;
        }

        // Make sure leading/trailing whitespace is removed (IE can't handle it)
        data = jQuery[sym__trim_]( data );

        // Attempt to parse using the native JSON parser first
        if ( sym__g_window_.JSON && sym__g_window_.JSON.parse ) {
            return sym__g_window_.JSON.parse( data );
        }

        // Make sure the incoming data is actual JSON
        // Logic borrowed from http://json.org/json2.js
        if ( rvalidchars[sym__test_]( data[sym__replace_]( rvalidescape, "@" )
            [sym__replace_]( rvalidtokens, "]" )
            [sym__replace_]( rvalidbraces, "")) ) {

            return ( new Function( "return " + data ) )();

        }
        jQuery[sym__error_]( "Invalid JSON: " + data );
    },

    // Cross-browser xml parsing
    parseXML: function( data ) {
        var xml, tmp;
        if ( !data || typeof data !== sym__string_ ) {
            return sym__g_null_;
        }
        try {
            if ( sym__g_window_.DOMParser ) { // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString( data , "text/xml" );
            } else { // IE
                xml = new ActiveXObject( "Microsoft.XMLDOM" );
                xml[sym__async_] = sym__false_;
                xml.loadXML( data );
            }
        } catch( e ) {
            xml = undefined;
        }
        if ( !xml || !xml[sym__documentElement_] || xml[sym__getElementsByTagName_]( sym__parsererror_ )[sym__length_] ) {
            jQuery[sym__error_]( "Invalid XML: " + data );
        }
        return xml;
    },

    noop: function() {},

    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function( data ) {
        if ( data && core_rnotwhite[sym__test_]( data ) ) {
            // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            ( sym__g_window_.execScript || function( data ) {
                sym__g_window_[ "eval" ][sym__call_]( sym__g_window_, data );
            } )( data );
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {
        return string[sym__replace_]( rmsPrefix, "ms-" )[sym__replace_]( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {
        return elem[sym__nodeName_] && elem[sym__nodeName_][sym__toLowerCase_]() === name[sym__toLowerCase_]();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var name,
            i = 0,
            length = obj[sym__length_],
            isObj = length === undefined || jQuery[sym__isFunction_]( obj );

        if ( args ) {
            if ( isObj ) {
                for ( name in obj ) {
                    if ( callback[sym__apply_]( obj[ name ], args ) === sym__g_false_ ) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if ( callback[sym__apply_]( obj[ i++ ], args ) === sym__g_false_ ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isObj ) {
                for ( name in obj ) {
                    if ( callback[sym__call_]( obj[ name ], name, obj[ name ] ) === sym__g_false_ ) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if ( callback[sym__call_]( obj[ i ], i, obj[ i++ ] ) === sym__g_false_ ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Use native String.trim function wherever possible
    trim: core_trim && !core_trim[sym__call_]("\uFEFF\xA0") ?
        function( text ) {
            return text == sym__g_null_ ?
                "" :
                core_trim[sym__call_]( text );
        } :

        // Otherwise use our own trimming functionality
        function( text ) {
            return text == sym__g_null_ ?
                "" :
                ( text + "" )[sym__replace_]( rtrim, "" );
        },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var type,
            ret = results || [];

        if ( arr != sym__g_null_ ) {
            // The window, strings (and functions) also have 'length'
            // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
            type = jQuery[sym__type_]( arr );

            if ( arr[sym__length_] == sym__g_null_ || type === sym__string_ || type === sym__function_ || type === "regexp" || jQuery[sym__isWindow_]( arr ) ) {
                core_push[sym__call_]( ret, arr );
            } else {
                jQuery[sym__merge_]( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( core_indexOf ) {
                return core_indexOf[sym__call_]( arr, elem, i );
            }

            len = arr[sym__length_];
            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i < len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr && arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var l = second[sym__length_],
            i = first[sym__length_],
            j = 0;

        if ( typeof l === sym__number_ ) {
            for ( ; j < l; j++ ) {
                first[ i++ ] = second[ j ];
            }

        } else {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first[sym__length_] = i;

        return first;
    },

    grep: function( elems, callback, inv ) {
        var retVal,
            ret = [],
            i = 0,
            length = elems[sym__length_];
        inv = !!inv;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i < length; i++ ) {
            retVal = !!callback( elems[ i ], i );
            if ( inv !== retVal ) {
                ret[sym__push_]( elems[ i ] );
            }
        }

        return ret;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value, key,
            ret = [],
            i = 0,
            length = elems[sym__length_],
            // jquery objects are treated as arrays
            isArray = elems instanceof jQuery || length !== undefined && typeof length === sym__number_ && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery[sym__isArray_]( elems ) ) ;

        // Go through the array, translating each of the items to their
        if ( isArray ) {
            for ( ; i < length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != sym__g_null_ ) {
                    ret[ ret[sym__length_] ] = value;
                }
            }

        // Go through every key on the object,
        } else {
            for ( key in elems ) {
                value = callback( elems[ key ], key, arg );

                if ( value != sym__g_null_ ) {
                    ret[ ret[sym__length_] ] = value;
                }
            }
        }

        // Flatten any nested arrays
        return ret[sym__concat_][sym__apply_]( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
        var tmp, args, proxy;

        if ( typeof context === sym__string_ ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery[sym__isFunction_]( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = core_slice[sym__call_]( arguments, 2 );
        proxy = function() {
            return fn[sym__apply_]( context, args[sym__concat_]( core_slice[sym__call_]( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy[sym__guid_] = fn[sym__guid_] = fn[sym__guid_] || jQuery[sym__guid_]++;

        return proxy;
    },

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
        var exec,
            bulk = key == sym__g_null_,
            i = 0,
            length = elems[sym__length_];

        // Sets many values
        if ( key && typeof key === sym__object_ ) {
            for ( i in key ) {
                jQuery[sym__access_]( elems, fn, i, key[i], 1, emptyGet, value );
            }
            chainable = 1;

        // Sets one value
        } else if ( value !== undefined ) {
            // Optionally, function values get executed if exec is true
            exec = pass === undefined && jQuery[sym__isFunction_]( value );

            if ( bulk ) {
                // Bulk operations only iterate when executing function values
                if ( exec ) {
                    exec = fn;
                    fn = function( elem, key, value ) {
                        return exec[sym__call_]( jQuery( elem ), value );
                    };

                // Otherwise they run against the entire set
                } else {
                    fn[sym__call_]( elems, value );
                    fn = sym__g_null_;
                }
            }

            if ( fn ) {
                for (; i < length; i++ ) {
                    fn( elems[i], key, exec ? value[sym__call_]( elems[i], i, fn( elems[i], key ) ) : value, pass );
                }
            }

            chainable = 1;
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn[sym__call_]( elems ) :
                length ? fn( elems[0], key ) : emptyGet;
    },

    now: function() {
        return ( new Date() ).getTime();
    }
});

jQuery[sym__ready_][sym__promise_] = function( obj ) {
    if ( !readyList ) {

        readyList = jQuery[sym__Deferred_]();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document[sym__readyState_] === sym__complete_ ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            setTimeout( jQuery[sym__ready_], 1 );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document[sym__addEventListener_] ) {
            // Use the handy event callback
            document[sym__addEventListener_]( sym__DOMContentLoaded_, DOMContentLoaded, sym__g_false_ );

            // A fallback to window.onload, that will always work
            sym__g_window_[sym__addEventListener_]( "load", jQuery[sym__ready_], sym__g_false_ );

        // If IE event model is used
        } else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document[sym__attachEvent_]( sym__onreadystatechange_, DOMContentLoaded );

            // A fallback to window.onload, that will always work
            sym__g_window_[sym__attachEvent_]( sym__onload_, jQuery[sym__ready_] );

            // If IE and not a frame
            // continually check to see if the document is ready
            var top = sym__g_false_;

            try {
                top = sym__g_window_.frameElement == sym__g_null_ && document[sym__documentElement_];
            } catch(e) {}

            if ( top && top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery[sym__isReady_] ) {

                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll(sym__left_);
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        // and execute any waiting functions
                        jQuery[sym__ready_]();
                    }
                })();
            }
        }
    }
    return readyList[sym__promise_]( obj );
};

// Populate the class2type map
jQuery[sym__each_]("Boolean Number String Function Array Date RegExp Object"[sym__split_](" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name[sym__toLowerCase_]();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    jQuery[sym__each_]( options[sym__split_]( core_rspace ), function( _, flag ) {
        object[ flag ] = sym__g_true_;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *          the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:           will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:         will keep track of previous values and will call any callback added
 *                  after the list has been fired right away with the latest "memorized"
 *                  values (like a Deferred)
 *
 *  unique:         will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:    interrupt callings when a callback returns false
 *
 */
jQuery[sym__Callbacks_] = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === sym__string_ ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery[sym__extend_]( {}, options );

    var // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to know if list is currently firing
        firing,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once && [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory && data;
            fired = sym__g_true_;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list[sym__length_];
            firing = sym__g_true_;
            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                if ( list[ firingIndex ][sym__apply_]( data[ 0 ], data[ 1 ] ) === sym__g_false_ && options.stopOnFalse ) {
                    memory = sym__g_false_; // To prevent further calls using add
                    break;
                }
            }
            firing = sym__g_false_;
            if ( list ) {
                if ( stack ) {
                    if ( stack[sym__length_] ) {
                        fire( stack[sym__shift_]() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self[sym__disable_]();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list[sym__length_];
                    (function add( args ) {
                        jQuery[sym__each_]( args, function( _, arg ) {
                            var type = jQuery[sym__type_]( arg );
                            if ( type === sym__function_ ) {
                                if ( !options[sym__unique_] || !self.has( arg ) ) {
                                    list[sym__push_]( arg );
                                }
                            } else if ( arg && arg[sym__length_] && type !== sym__string_ ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list[sym__length_];
                    // With memory, if we're not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if ( list ) {
                    jQuery[sym__each_]( arguments, function( _, arg ) {
                        var index;
                        while( ( index = jQuery[sym__inArray_]( arg, list, index ) ) > -1 ) {
                            list[sym__splice_]( index, 1 );
                            // Handle firing indexes
                            if ( firing ) {
                                if ( index <= firingLength ) {
                                    firingLength--;
                                }
                                if ( index <= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Control if a given callback is in the list
            has: function( fn ) {
                return jQuery[sym__inArray_]( fn, list ) > -1;
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if ( !memory ) {
                    self[sym__disable_]();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                args = args || [];
                args = [ context, args[sym__slice_] ? args[sym__slice_]() : args ];
                if ( list && ( !fired || stack ) ) {
                    if ( firing ) {
                        stack[sym__push_]( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self[sym__fireWith_]( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

    return self;
};
jQuery[sym__extend_]({

    Deferred: function( func ) {
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", sym__done_, jQuery[sym__Callbacks_]("once memory"), "resolved" ],
                [ sym__reject_, sym__fail_, jQuery[sym__Callbacks_]("once memory"), "rejected" ],
                [ "notify", sym__progress_, jQuery[sym__Callbacks_]("memory") ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred[sym__done_]( arguments )[sym__fail_]( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return jQuery[sym__Deferred_](function( newDefer ) {
                        jQuery[sym__each_]( tuples, function( i, tuple ) {
                            var action = tuple[ 0 ],
                                fn = fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ]( jQuery[sym__isFunction_]( fn ) ?
                                function() {
                                    var returned = fn[sym__apply_]( this, arguments );
                                    if ( returned && jQuery[sym__isFunction_]( returned[sym__promise_] ) ) {
                                        returned[sym__promise_]()
                                            [sym__done_]( newDefer.resolve )
                                            [sym__fail_]( newDefer[sym__reject_] )
                                            [sym__progress_]( newDefer.notify );
                                    } else {
                                        newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
                                    }
                                } :
                                newDefer[ action ]
                            );
                        });
                        fns = sym__g_null_;
                    })[sym__promise_]();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != sym__g_null_ ? jQuery[sym__extend_]( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery[sym__each_]( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add
            promise[ tuple[1] ] = list[sym__add_];

            // Handle state
            if ( stateString ) {
                list[sym__add_](function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock
                }, tuples[ i ^ 1 ][ 2 ][sym__disable_], tuples[ 2 ][ 2 ].lock );
            }

            // deferred[ resolve | reject | notify ] = list.fire
            deferred[ tuple[0] ] = list[sym__fire_];
            deferred[ tuple[0] + "With" ] = list[sym__fireWith_];
        });

        // Make the deferred a promise
        promise[sym__promise_]( deferred );

        // Call given func if any
        if ( func ) {
            func[sym__call_]( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = core_slice[sym__call_]( arguments ),
            length = resolveValues[sym__length_],

            // the count of uncompleted subordinates
            remaining = length !== 1 || ( subordinate && jQuery[sym__isFunction_]( subordinate[sym__promise_] ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery[sym__Deferred_](),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments[sym__length_] > 1 ? core_slice[sym__call_]( arguments ) : value;
                    if( values === progressValues ) {
                        deferred[sym__notifyWith_]( contexts, values );
                    } else if ( !( --remaining ) ) {
                        deferred[sym__resolveWith_]( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length > 1 ) {
            progressValues = new Array( length );
            progressContexts = new Array( length );
            resolveContexts = new Array( length );
            for ( ; i < length; i++ ) {
                if ( resolveValues[ i ] && jQuery[sym__isFunction_]( resolveValues[ i ][sym__promise_] ) ) {
                    resolveValues[ i ][sym__promise_]()
                        [sym__done_]( updateFunc( i, resolveContexts, resolveValues ) )
                        [sym__fail_]( deferred[sym__reject_] )
                        [sym__progress_]( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    --remaining;
                }
            }
        }

        // if we're not waiting on anything, resolve the master
        if ( !remaining ) {
            deferred[sym__resolveWith_]( resolveContexts, resolveValues );
        }

        return deferred[sym__promise_]();
    }
});
jQuery[sym__support_] = (function() {

    var support,
        all,
        a,
        select,
        opt,
        input,
        fragment,
        eventName,
        i,
        isSupported,
        clickFn,
        div = document[sym__createElement_](sym__div_);

    // Setup
    div[sym__setAttribute_]( sym__className_, "t" );
    div[sym__innerHTML_] = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

    // Support tests won't run in some limited or non-browser environments
    all = div[sym__getElementsByTagName_]("*");
    a = div[sym__getElementsByTagName_]("a")[ 0 ];
    if ( !all || !a || !all[sym__length_] ) {
        return {};
    }

    // First batch of tests
    select = document[sym__createElement_]("select");
    opt = select[sym__appendChild_]( document[sym__createElement_](sym__option_) );
    input = div[sym__getElementsByTagName_](sym__input_)[ 0 ];

    a[sym__style_][sym__cssText_] = "top:1px;float:left;opacity:.5";
    support = {
        // IE strips leading whitespace when .innerHTML is used
        leadingWhitespace: ( div[sym__firstChild_][sym__nodeType_] === 3 ),

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        tbody: !div[sym__getElementsByTagName_](sym__tbody_)[sym__length_],

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        htmlSerialize: !!div[sym__getElementsByTagName_]("link")[sym__length_],

        // Get the style information from getAttribute
        // (IE uses .cssText instead)
        style: /top/[sym__test_]( a[sym__getAttribute_](sym__style_) ),

        // Make sure that URLs aren't manipulated
        // (IE normalizes it by default)
        hrefNormalized: ( a[sym__getAttribute_](sym__href_) === "/a" ),

        // Make sure that element opacity exists
        // (IE uses filter instead)
        // Use a regex to work around a WebKit issue. See #5145
        opacity: /^0.5/[sym__test_]( a[sym__style_][sym__opacity_] ),

        // Verify style float existence
        // (IE uses styleFloat instead of cssFloat)
        cssFloat: !!a[sym__style_][sym__cssFloat_],

        // Make sure that if no value is specified for a checkbox
        // that it defaults to "on".
        // (WebKit defaults to "" instead)
        checkOn: ( input[sym__value_] === sym__on_ ),

        // Make sure that a selected-by-default option has a working selected property.
        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
        optSelected: opt[sym__selected_],

        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
        getSetAttribute: div[sym__className_] !== "t",

        // Tests for enctype support on a form (#6743)
        enctype: !!document[sym__createElement_](sym__form_)[sym__enctype_],

        // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        html5Clone: document[sym__createElement_]("nav")[sym__cloneNode_]( sym__g_true_ )[sym__outerHTML_] !== "<:nav></:nav>",

        // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
        boxModel: ( document.compatMode === "CSS1Compat" ),

        // Will be defined later
        submitBubbles: sym__g_true_,
        changeBubbles: sym__g_true_,
        focusinBubbles: sym__g_false_,
        deleteExpando: sym__g_true_,
        noCloneEvent: sym__g_true_,
        inlineBlockNeedsLayout: sym__g_false_,
        shrinkWrapBlocks: sym__g_false_,
        reliableMarginRight: sym__g_true_,
        boxSizingReliable: sym__g_true_,
        pixelPosition: sym__g_false_
    };

    // Make sure checked status is properly cloned
    input[sym__checked_] = sym__g_true_;
    support[sym__noCloneChecked_] = input[sym__cloneNode_]( sym__g_true_ )[sym__checked_];

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select[sym__disabled_] = sym__g_true_;
    support[sym__optDisabled_] = !opt[sym__disabled_];

    // Test to see if it's possible to delete an expando from an element
    // Fails in Internet Explorer
    try {
        delete div[sym__test_];
    } catch( e ) {
        support[sym__deleteExpando_] = sym__g_false_;
    }

    if ( !div[sym__addEventListener_] && div[sym__attachEvent_] && div[sym__fireEvent_] ) {
        div[sym__attachEvent_]( sym__onclick_, clickFn = function() {
            // Cloning a node shouldn't copy over any
            // bound event handlers (IE does this)
            support[sym__noCloneEvent_] = sym__g_false_;
        });
        div[sym__cloneNode_]( sym__g_true_ )[sym__fireEvent_](sym__onclick_);
        div[sym__detachEvent_]( sym__onclick_, clickFn );
    }

    // Check if a radio maintains its value
    // after being appended to the DOM
    input = document[sym__createElement_](sym__input_);
    input[sym__value_] = "t";
    input[sym__setAttribute_]( sym__type_, sym__radio_ );
    support[sym__radioValue_] = input[sym__value_] === "t";

    input[sym__setAttribute_]( sym__checked_, sym__checked_ );

    // #11217 - WebKit loses check when the name is after the checked attribute
    input[sym__setAttribute_]( sym__name_, "t" );

    div[sym__appendChild_]( input );
    fragment = document[sym__createDocumentFragment_]();
    fragment[sym__appendChild_]( div[sym__lastChild_] );

    // WebKit doesn't clone checked state correctly in fragments
    support[sym__checkClone_] = fragment[sym__cloneNode_]( sym__g_true_ )[sym__cloneNode_]( sym__g_true_ )[sym__lastChild_][sym__checked_];

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    support[sym__appendChecked_] = input[sym__checked_];

    fragment[sym__removeChild_]( input );
    fragment[sym__appendChild_]( div );

    // Technique from Juriy Zaytsev
    // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    // We only care about the case where non-standard event systems
    // are used, namely in IE. Short-circuiting here helps us to
    // avoid an eval call (in setAttribute) which can cause CSP
    // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
    if ( div[sym__attachEvent_] ) {
        for ( i in {
            submit: sym__g_true_,
            change: sym__g_true_,
            focusin: sym__g_true_
        }) {
            eventName = sym__on_ + i;
            isSupported = ( eventName in div );
            if ( !isSupported ) {
                div[sym__setAttribute_]( eventName, "return;" );
                isSupported = ( typeof div[ eventName ] === sym__function_ );
            }
            support[ i + "Bubbles" ] = isSupported;
        }
    }

    // Run tests that need a body at doc ready
    jQuery(function() {
        var container, div, tds, marginDiv,
            divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
            body = document[sym__getElementsByTagName_](sym__body_)[0];

        if ( !body ) {
            // Return for frameset docs that don't have a body
            return;
        }

        container = document[sym__createElement_](sym__div_);
        container[sym__style_][sym__cssText_] = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
        body[sym__insertBefore_]( container, body[sym__firstChild_] );

        // Construct the test element
        div = document[sym__createElement_](sym__div_);
        container[sym__appendChild_]( div );

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        div[sym__innerHTML_] = "<table><tr><td></td><td>t</td></tr></table>";
        tds = div[sym__getElementsByTagName_]("td");
        tds[ 0 ][sym__style_][sym__cssText_] = "padding:0;margin:0;border:0;display:none";
        isSupported = ( tds[ 0 ][sym__offsetHeight_] === 0 );

        tds[ 0 ][sym__style_][sym__display_] = "";
        tds[ 1 ][sym__style_][sym__display_] = sym__none_;

        // Check if empty table cells still have offsetWidth/Height
        // (IE <= 8 fail this test)
        support[sym__reliableHiddenOffsets_] = isSupported && ( tds[ 0 ][sym__offsetHeight_] === 0 );

        // Check box-sizing and margin behavior
        div[sym__innerHTML_] = "";
        div[sym__style_][sym__cssText_] = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
        support[sym__boxSizing_] = ( div[sym__offsetWidth_] === 4 );
        support[sym__doesNotIncludeMarginInBodyOffset_] = ( body[sym__offsetTop_] !== 1 );

        // NOTE: To any future maintainer, we've window.getComputedStyle
        // because jsdom on node.js will break without it.
        if ( sym__g_window_[sym__getComputedStyle_] ) {
            support[sym__pixelPosition_] = ( sym__g_window_[sym__getComputedStyle_]( div, sym__g_null_ ) || {} )[sym__top_] !== "1%";
            support[sym__boxSizingReliable_] = ( sym__g_window_[sym__getComputedStyle_]( div, sym__g_null_ ) || { width: "4px" } )[sym__width_] === "4px";

            // Check if div with explicit width and no margin-right incorrectly
            // gets computed margin-right based on width of container. For more
            // info see bug #3333
            // Fails in WebKit before Feb 2011 nightlies
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            marginDiv = document[sym__createElement_](sym__div_);
            marginDiv[sym__style_][sym__cssText_] = div[sym__style_][sym__cssText_] = divReset;
            marginDiv[sym__style_][sym__marginRight_] = marginDiv[sym__style_][sym__width_] = "0";
            div[sym__style_][sym__width_] = "1px";
            div[sym__appendChild_]( marginDiv );
            support[sym__reliableMarginRight_] =
                !parseFloat( ( sym__g_window_[sym__getComputedStyle_]( marginDiv, sym__g_null_ ) || {} )[sym__marginRight_] );
        }

        if ( typeof div[sym__style_][sym__zoom_] !== sym__undefined_ ) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div[sym__innerHTML_] = "";
            div[sym__style_][sym__cssText_] = divReset + "width:1px;padding:1px;display:inline;zoom:1";
            support[sym__inlineBlockNeedsLayout_] = ( div[sym__offsetWidth_] === 3 );

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div[sym__style_][sym__display_] = sym__block_;
            div[sym__style_][sym__overflow_] = "visible";
            div[sym__innerHTML_] = "<div></div>";
            div[sym__firstChild_][sym__style_][sym__width_] = "5px";
            support[sym__shrinkWrapBlocks_] = ( div[sym__offsetWidth_] !== 3 );

            container[sym__style_][sym__zoom_] = 1;
        }

        // Null elements to avoid leaks in IE
        body[sym__removeChild_]( container );
        container = div = tds = marginDiv = sym__g_null_;
    });

    // Null elements to avoid leaks in IE
    fragment[sym__removeChild_]( div );
    all = a = select = opt = input = fragment = div = sym__g_null_;

    return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
    rmultiDash = /([A-Z])/g;

jQuery[sym__extend_]({
    cache: {},

    deletedIds: [],

    // Remove at next major release (1.9/2.0)
    uuid: 0,

    // Unique for each copy of jQuery on the page
    // Non-digits removed to match rinlinejQuery
    expando: sym__jQuery_ + ( jQuery[sym__fn_][sym__jquery_] + Math.random() )[sym__replace_]( /\D/g, "" ),

    // The following elements throw uncatchable exceptions if you
    // attempt to add expando properties to them.
    noData: {
        "embed": sym__g_true_,
        // Ban all objects except for Flash (which handle expandos)
        "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
        "applet": sym__g_true_
    },

    hasData: function( elem ) {
        elem = elem[sym__nodeType_] ? jQuery[sym__cache_][ elem[jQuery[sym__expando_]] ] : elem[ jQuery[sym__expando_] ];
        return !!elem && !isEmptyDataObject( elem );
    },

    data: function( elem, name, data, pvt /* Internal Use Only */ ) {
        if ( !jQuery[sym__acceptData_]( elem ) ) {
            return;
        }

        var thisCache, ret,
            internalKey = jQuery[sym__expando_],
            getByName = typeof name === sym__string_,

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
            isNode = elem[sym__nodeType_],

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
            cache = isNode ? jQuery[sym__cache_] : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
            id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

        // Avoid doing any more work than we need to when trying to get data on an
        // object that has no data at all
        if ( (!id || !cache[id] || (!pvt && !cache[id][sym__data_])) && getByName && data === undefined ) {
            return;
        }

        if ( !id ) {
            // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            if ( isNode ) {
                elem[ internalKey ] = id = jQuery[sym__deletedIds_].pop() || jQuery[sym__guid_]++;
            } else {
                id = internalKey;
            }
        }

        if ( !cache[ id ] ) {
            cache[ id ] = {};

            // Avoids exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            if ( !isNode ) {
                cache[ id ].toJSON = jQuery.noop;
            }
        }

        // An object can be passed to jQuery.data instead of a key/value pair; this gets
        // shallow copied over onto the existing cache
        if ( typeof name === sym__object_ || typeof name === sym__function_ ) {
            if ( pvt ) {
                cache[ id ] = jQuery[sym__extend_]( cache[ id ], name );
            } else {
                cache[ id ][sym__data_] = jQuery[sym__extend_]( cache[ id ][sym__data_], name );
            }
        }

        thisCache = cache[ id ];

        // jQuery data() is stored in a separate object inside the object's internal data
        // cache in order to avoid key collisions between internal data and user-defined
        // data.
        if ( !pvt ) {
            if ( !thisCache[sym__data_] ) {
                thisCache[sym__data_] = {};
            }

            thisCache = thisCache[sym__data_];
        }

        if ( data !== undefined ) {
            thisCache[ jQuery[sym__camelCase_]( name ) ] = data;
        }

        // Check for both converted-to-camel and non-converted data property names
        // If a data property was specified
        if ( getByName ) {

            // First Try to find as-is property data
            ret = thisCache[ name ];

            // Test for null|undefined property data
            if ( ret == sym__g_null_ ) {

                // Try to find the camelCased property
                ret = thisCache[ jQuery[sym__camelCase_]( name ) ];
            }
        } else {
            ret = thisCache;
        }

        return ret;
    },

    removeData: function( elem, name, pvt /* Internal Use Only */ ) {
        if ( !jQuery[sym__acceptData_]( elem ) ) {
            return;
        }

        var thisCache, i, l,

            isNode = elem[sym__nodeType_],

            // See jQuery.data for more information
            cache = isNode ? jQuery[sym__cache_] : elem,
            id = isNode ? elem[ jQuery[sym__expando_] ] : jQuery[sym__expando_];

        // If there is already no cache entry for this object, there is no
        // purpose in continuing
        if ( !cache[ id ] ) {
            return;
        }

        if ( name ) {

            thisCache = pvt ? cache[ id ] : cache[ id ][sym__data_];

            if ( thisCache ) {

                // Support array or space separated string names for data keys
                if ( !jQuery[sym__isArray_]( name ) ) {

                    // try the string as a key before any manipulation
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {

                        // split the camel cased version by spaces unless a key with the spaces exists
                        name = jQuery[sym__camelCase_]( name );
                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {
                            name = name[sym__split_](" ");
                        }
                    }
                }

                for ( i = 0, l = name[sym__length_]; i < l; i++ ) {
                    delete thisCache[ name[i] ];
                }

                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if ( !( pvt ? isEmptyDataObject : jQuery[sym__isEmptyObject_] )( thisCache ) ) {
                    return;
                }
            }
        }

        // See jQuery.data for more information
        if ( !pvt ) {
            delete cache[ id ][sym__data_];

            // Don't destroy the parent cache unless the internal data object
            // had been the only thing left in it
            if ( !isEmptyDataObject( cache[ id ] ) ) {
                return;
            }
        }

        // Destroy the cache
        if ( isNode ) {
            jQuery[sym__cleanData_]( [ elem ], sym__g_true_ );

        // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
        } else if ( jQuery[sym__support_][sym__deleteExpando_] || cache != cache.sym__g_window_ ) {
            delete cache[ id ];

        // When all else fails, null
        } else {
            cache[ id ] = sym__g_null_;
        }
    },

    // For internal use only.
    _data: function( elem, name, data ) {
        return jQuery[sym__data_]( elem, name, data, sym__g_true_ );
    },

    // A method for determining if a DOM node can handle the data expando
    acceptData: function( elem ) {
        var noData = elem[sym__nodeName_] && jQuery.noData[ elem[sym__nodeName_][sym__toLowerCase_]() ];

        // nodes accept data unless otherwise specified; rejection can be conditional
        return !noData || noData !== sym__g_true_ && elem[sym__getAttribute_]("classid") === noData;
    }
});

jQuery[sym__fn_][sym__extend_]({
    data: function( key, value ) {
        var parts, part, attr, name, l,
            elem = this[0],
            i = 0,
            data = sym__g_null_;

        // Gets all values
        if ( key === undefined ) {
            if ( this[sym__length_] ) {
                data = jQuery[sym__data_]( elem );

                if ( elem[sym__nodeType_] === 1 && !jQuery._data( elem, sym__parsedAttrs_ ) ) {
                    attr = elem[sym__attributes_];
                    for ( l = attr[sym__length_]; i < l; i++ ) {
                        name = attr[i][sym__name_];

                        if ( !name[sym__indexOf_]( "data-" ) ) {
                            name = jQuery[sym__camelCase_]( name.substring(5) );

                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                    jQuery._data( elem, sym__parsedAttrs_, sym__g_true_ );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === sym__object_ ) {
            return this[sym__each_](function() {
                jQuery[sym__data_]( this, key );
            });
        }

        parts = key[sym__split_]( ".", 2 );
        parts[1] = parts[1] ? "." + parts[1] : "";
        part = parts[1] + "!";

        return jQuery[sym__access_]( this, function( value ) {

            if ( value === undefined ) {
                data = this[sym__triggerHandler_]( "getData" + part, [ parts[0] ] );

                // Try to fetch any internally stored data first
                if ( data === undefined && elem ) {
                    data = jQuery[sym__data_]( elem, key );
                    data = dataAttr( elem, key, data );
                }

                return data === undefined && parts[1] ?
                    this[sym__data_]( parts[0] ) :
                    data;
            }

            parts[1] = value;
            this[sym__each_](function() {
                var self = jQuery( this );

                self[sym__triggerHandler_]( "setData" + part, parts );
                jQuery[sym__data_]( this, key, value );
                self[sym__triggerHandler_]( sym__changeData_ + part, parts );
            });
        }, sym__g_null_, value, arguments[sym__length_] > 1, sym__g_null_, sym__g_false_ );
    },

    removeData: function( key ) {
        return this[sym__each_](function() {
            jQuery[sym__removeData_]( this, key );
        });
    }
});

function dataAttr( elem, key, data ) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem[sym__nodeType_] === 1 ) {

        var name = "data-" + key[sym__replace_]( rmultiDash, "-$1" )[sym__toLowerCase_]();

        data = elem[sym__getAttribute_]( name );

        if ( typeof data === sym__string_ ) {
            try {
                data = data === "true" ? sym__g_true_ :
                data === sym__false_ ? sym__g_false_ :
                data === "null" ? sym__g_null_ :
                // Only convert to a number if it doesn't change the string
                +data + "" === data ? +data :
                rbrace[sym__test_]( data ) ? jQuery[sym__parseJSON_]( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn't changed later
            jQuery[sym__data_]( elem, key, data );

        } else {
            data = undefined;
        }
    }

    return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
    var name;
    for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === sym__data_ && jQuery[sym__isEmptyObject_]( obj[name] ) ) {
            continue;
        }
        if ( name !== "toJSON" ) {
            return sym__g_false_;
        }
    }

    return sym__g_true_;
}
jQuery[sym__extend_]({
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            type = ( type || sym__fx_ ) + sym__queue_;
            queue = jQuery._data( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                if ( !queue || jQuery[sym__isArray_](data) ) {
                    queue = jQuery._data( elem, type, jQuery[sym__makeArray_](data) );
                } else {
                    queue[sym__push_]( data );
                }
            }
            return queue || [];
        }
    },

    dequeue: function( elem, type ) {
        type = type || sym__fx_;

        var queue = jQuery[sym__queue_]( elem, type ),
            startLength = queue[sym__length_],
            fn = queue[sym__shift_](),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
                jQuery[sym__dequeue_]( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === sym__inprogress_ ) {
            fn = queue[sym__shift_]();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === sym__fx_ ) {
                queue[sym__unshift_]( sym__inprogress_ );
            }

            // clear up the last queue stop function
            delete hooks[sym__stop_];
            fn[sym__call_]( elem, next, hooks );
        }

        if ( !startLength && hooks ) {
            hooks[sym__empty_][sym__fire_]();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
        var key = type + sym__queueHooks_;
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
            empty: jQuery[sym__Callbacks_]("once memory")[sym__add_](function() {
                jQuery[sym__removeData_]( elem, type + sym__queue_, sym__g_true_ );
                jQuery[sym__removeData_]( elem, key, sym__g_true_ );
            })
        });
    }
});

jQuery[sym__fn_][sym__extend_]({
    queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== sym__string_ ) {
            data = type;
            type = sym__fx_;
            setter--;
        }

        if ( arguments[sym__length_] < setter ) {
            return jQuery[sym__queue_]( this[0], type );
        }

        return data === undefined ?
            this :
            this[sym__each_](function() {
                var queue = jQuery[sym__queue_]( this, type, data );

                // ensure a hooks for this queue
                jQuery._queueHooks( this, type );

                if ( type === sym__fx_ && queue[0] !== sym__inprogress_ ) {
                    jQuery[sym__dequeue_]( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this[sym__each_](function() {
            jQuery[sym__dequeue_]( this, type );
        });
    },
    // Based off of the plugin by Clint Helfers, with permission.
    // http://blindsignals.com/index.php/2009/07/jquery-delay/
    delay: function( time, type ) {
        time = jQuery[sym__fx_] ? jQuery[sym__fx_][sym__speeds_][ time ] || time : time;
        type = type || sym__fx_;

        return this[sym__queue_]( type, function( next, hooks ) {
            var timeout = setTimeout( next, time );
            hooks[sym__stop_] = function() {
                clearTimeout( timeout );
            };
        });
    },
    clearQueue: function( type ) {
        return this[sym__queue_]( type || sym__fx_, [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery[sym__Deferred_](),
            elements = this,
            i = this[sym__length_],
            resolve = function() {
                if ( !( --count ) ) {
                    defer[sym__resolveWith_]( elements, [ elements ] );
                }
            };

        if ( typeof type !== sym__string_ ) {
            obj = type;
            type = undefined;
        }
        type = type || sym__fx_;

        while( i-- ) {
            tmp = jQuery._data( elements[ i ], type + sym__queueHooks_ );
            if ( tmp && tmp[sym__empty_] ) {
                count++;
                tmp[sym__empty_][sym__add_]( resolve );
            }
        }
        resolve();
        return defer[sym__promise_]( obj );
    }
});
var nodeHook, boolHook, fixSpecified,
    rclass = /[\t\r\n]/g,
    rreturn = /\r/g,
    rtype = /^(?:button|input)$/i,
    rfocusable = /^(?:button|input|object|select|textarea)$/i,
    rclickable = /^a(?:rea|)$/i,
    rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
    getSetAttribute = jQuery[sym__support_].getSetAttribute;

jQuery[sym__fn_][sym__extend_]({
    attr: function( name, value ) {
        return jQuery[sym__access_]( this, jQuery[sym__attr_], name, value, arguments[sym__length_] > 1 );
    },

    removeAttr: function( name ) {
        return this[sym__each_](function() {
            jQuery[sym__removeAttr_]( this, name );
        });
    },

    prop: function( name, value ) {
        return jQuery[sym__access_]( this, jQuery[sym__prop_], name, value, arguments[sym__length_] > 1 );
    },

    removeProp: function( name ) {
        name = jQuery[sym__propFix_][ name ] || name;
        return this[sym__each_](function() {
            // try/catch handles cases where IE balks (such as removing a property on window)
            try {
                this[ name ] = undefined;
                delete this[ name ];
            } catch( e ) {}
        });
    },

    addClass: function( value ) {
        var classNames, i, l, elem,
            setClass, c, cl;

        if ( jQuery[sym__isFunction_]( value ) ) {
            return this[sym__each_](function( j ) {
                jQuery( this ).addClass( value[sym__call_](this, j, this[sym__className_]) );
            });
        }

        if ( value && typeof value === sym__string_ ) {
            classNames = value[sym__split_]( core_rspace );

            for ( i = 0, l = this[sym__length_]; i < l; i++ ) {
                elem = this[ i ];

                if ( elem[sym__nodeType_] === 1 ) {
                    if ( !elem[sym__className_] && classNames[sym__length_] === 1 ) {
                        elem[sym__className_] = value;

                    } else {
                        setClass = " " + elem[sym__className_] + " ";

                        for ( c = 0, cl = classNames[sym__length_]; c < cl; c++ ) {
                            if ( setClass[sym__indexOf_]( " " + classNames[ c ] + " " ) < 0 ) {
                                setClass += classNames[ c ] + " ";
                            }
                        }
                        elem[sym__className_] = jQuery[sym__trim_]( setClass );
                    }
                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var removes, className, elem, c, cl, i, l;

        if ( jQuery[sym__isFunction_]( value ) ) {
            return this[sym__each_](function( j ) {
                jQuery( this )[sym__removeClass_]( value[sym__call_](this, j, this[sym__className_]) );
            });
        }
        if ( (value && typeof value === sym__string_) || value === undefined ) {
            removes = ( value || "" )[sym__split_]( core_rspace );

            for ( i = 0, l = this[sym__length_]; i < l; i++ ) {
                elem = this[ i ];
                if ( elem[sym__nodeType_] === 1 && elem[sym__className_] ) {

                    className = (" " + elem[sym__className_] + " ")[sym__replace_]( rclass, " " );

                    // loop over each item in the removal list
                    for ( c = 0, cl = removes[sym__length_]; c < cl; c++ ) {
                        // Remove until there is nothing to remove,
                        while ( className[sym__indexOf_](" " + removes[ c ] + " ") >= 0 ) {
                            className = className[sym__replace_]( " " + removes[ c ] + " " , " " );
                        }
                    }
                    elem[sym__className_] = value ? jQuery[sym__trim_]( className ) : "";
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value,
            isBool = typeof stateVal === sym__boolean_;

        if ( jQuery[sym__isFunction_]( value ) ) {
            return this[sym__each_](function( i ) {
                jQuery( this ).toggleClass( value[sym__call_](this, i, this[sym__className_], stateVal), stateVal );
            });
        }

        return this[sym__each_](function() {
            if ( type === sym__string_ ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    state = stateVal,
                    classNames = value[sym__split_]( core_rspace );

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    state = isBool ? state : !self.hasClass( className );
                    self[ state ? "addClass" : sym__removeClass_ ]( className );
                }

            } else if ( type === sym__undefined_ || type === sym__boolean_ ) {
                if ( this[sym__className_] ) {
                    // store className if set
                    jQuery._data( this, "__className__", this[sym__className_] );
                }

                // toggle whole className
                this[sym__className_] = this[sym__className_] || value === sym__g_false_ ? "" : jQuery._data( this, "__className__" ) || "";
            }
        });
    },

    hasClass: function( selector ) {
        var className = " " + selector + " ",
            i = 0,
            l = this[sym__length_];
        for ( ; i < l; i++ ) {
            if ( this[i][sym__nodeType_] === 1 && (" " + this[i][sym__className_] + " ")[sym__replace_](rclass, " ")[sym__indexOf_]( className ) >= 0 ) {
                return sym__g_true_;
            }
        }

        return sym__g_false_;
    },

    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments[sym__length_] ) {
            if ( elem ) {
                hooks = jQuery[sym__valHooks_][ elem[sym__type_] ] || jQuery[sym__valHooks_][ elem[sym__nodeName_][sym__toLowerCase_]() ];

                if ( hooks && sym__get_ in hooks && (ret = hooks[sym__get_]( elem, sym__value_ )) !== undefined ) {
                    return ret;
                }

                ret = elem[sym__value_];

                return typeof ret === sym__string_ ?
                    // handle most common string cases
                    ret[sym__replace_](rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == sym__g_null_ ? "" : ret;
            }

            return;
        }

        isFunction = jQuery[sym__isFunction_]( value );

        return this[sym__each_](function( i ) {
            var val,
                self = jQuery(this);

            if ( this[sym__nodeType_] !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value[sym__call_]( this, i, self.val() );
            } else {
                val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == sym__g_null_ ) {
                val = "";
            } else if ( typeof val === sym__number_ ) {
                val += "";
            } else if ( jQuery[sym__isArray_]( val ) ) {
                val = jQuery[sym__map_](val, function ( value ) {
                    return value == sym__g_null_ ? "" : value + "";
                });
            }

            hooks = jQuery[sym__valHooks_][ this[sym__type_] ] || jQuery[sym__valHooks_][ this[sym__nodeName_][sym__toLowerCase_]() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !(sym__set_ in hooks) || hooks[sym__set_]( this, val, sym__value_ ) === undefined ) {
                this[sym__value_] = val;
            }
        });
    }
});

jQuery[sym__extend_]({
    valHooks: {
        option: {
            get: function( elem ) {
                // attributes.value is undefined in Blackberry 4.7 but
                // uses .value. See #6932
                var val = elem[sym__attributes_][sym__value_];
                return !val || val[sym__specified_] ? elem[sym__value_] : elem[sym__text_];
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem[sym__options_],
                    index = elem[sym__selectedIndex_],
                    one = elem[sym__type_] === "select-one" || index < 0,
                    values = one ? sym__g_null_ : [],
                    max = one ? index + 1 : options[sym__length_],
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i < max; i++ ) {
                    option = options[ i ];

                    // oldIE doesn't update selected after form reset (#2551)
                    if ( ( option[sym__selected_] || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( jQuery[sym__support_][sym__optDisabled_] ? !option[sym__disabled_] : option[sym__getAttribute_](sym__disabled_) === sym__g_null_ ) &&
                            ( !option[sym__parentNode_][sym__disabled_] || !jQuery[sym__nodeName_]( option[sym__parentNode_], "optgroup" ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don't need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values[sym__push_]( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var values = jQuery[sym__makeArray_]( value );

                jQuery(elem)[sym__find_](sym__option_)[sym__each_](function() {
                    this[sym__selected_] = jQuery[sym__inArray_]( jQuery(this).val(), values ) >= 0;
                });

                if ( !values[sym__length_] ) {
                    elem[sym__selectedIndex_] = -1;
                }
                return values;
            }
        }
    },

    // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
    attrFn: {},

    attr: function( elem, name, value, pass ) {
        var ret, hooks, notxml,
            nType = elem[sym__nodeType_];

        // don't get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        if ( pass && jQuery[sym__isFunction_]( jQuery[sym__fn_][ name ] ) ) {
            return jQuery( elem )[ name ]( value );
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem[sym__getAttribute_] === sym__undefined_ ) {
            return jQuery[sym__prop_]( elem, name, value );
        }

        notxml = nType !== 1 || !jQuery[sym__isXMLDoc_]( elem );

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( notxml ) {
            name = name[sym__toLowerCase_]();
            hooks = jQuery[sym__attrHooks_][ name ] || ( rboolean[sym__test_]( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === sym__g_null_ ) {
                jQuery[sym__removeAttr_]( elem, name );
                return;

            } else if ( hooks && sym__set_ in hooks && notxml && (ret = hooks[sym__set_]( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem[sym__setAttribute_]( name, value + "" );
                return value;
            }

        } else if ( hooks && sym__get_ in hooks && notxml && (ret = hooks[sym__get_]( elem, name )) !== sym__g_null_ ) {
            return ret;

        } else {

            ret = elem[sym__getAttribute_]( name );

            // Non-existent attributes return null, we normalize to undefined
            return ret === sym__g_null_ ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var propName, attrNames, name, isBool,
            i = 0;

        if ( value && elem[sym__nodeType_] === 1 ) {

            attrNames = value[sym__split_]( core_rspace );

            for ( ; i < attrNames[sym__length_]; i++ ) {
                name = attrNames[ i ];

                if ( name ) {
                    propName = jQuery[sym__propFix_][ name ] || name;
                    isBool = rboolean[sym__test_]( name );

                    // See #9699 for explanation of this approach (setting first, then removal)
                    // Do not do this for boolean attributes (see #10870)
                    if ( !isBool ) {
                        jQuery[sym__attr_]( elem, name, "" );
                    }
                    elem[sym__removeAttribute_]( getSetAttribute ? name : propName );

                    // Set corresponding property to false for boolean attributes
                    if ( isBool && propName in elem ) {
                        elem[ propName ] = sym__g_false_;
                    }
                }
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                // We can't allow the type property to be changed (since it causes problems in IE)
                if ( rtype[sym__test_]( elem[sym__nodeName_] ) && elem[sym__parentNode_] ) {
                    jQuery[sym__error_]( "type property can't be changed" );
                } else if ( !jQuery[sym__support_][sym__radioValue_] && value === sym__radio_ && jQuery[sym__nodeName_](elem, sym__input_) ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to it's default in case type is set after value
                    // This is for element creation
                    var val = elem[sym__value_];
                    elem[sym__setAttribute_]( sym__type_, value );
                    if ( val ) {
                        elem[sym__value_] = val;
                    }
                    return value;
                }
            }
        },
        // Use the value property for back compat
        // Use the nodeHook for button elements in IE6/7 (#1954)
        value: {
            get: function( elem, name ) {
                if ( nodeHook && jQuery[sym__nodeName_]( elem, sym__button_ ) ) {
                    return nodeHook[sym__get_]( elem, name );
                }
                return name in elem ?
                    elem[sym__value_] :
                    sym__g_null_;
            },
            set: function( elem, value, name ) {
                if ( nodeHook && jQuery[sym__nodeName_]( elem, sym__button_ ) ) {
                    return nodeHook[sym__set_]( elem, value, name );
                }
                // Does not return so that setAttribute is also used
                elem[sym__value_] = value;
            }
        }
    },

    propFix: {
        tabindex: "tabIndex",
        readonly: "readOnly",
        "for": "htmlFor",
        "class": sym__className_,
        maxlength: "maxLength",
        cellspacing: "cellSpacing",
        cellpadding: "cellPadding",
        rowspan: "rowSpan",
        colspan: "colSpan",
        usemap: "useMap",
        frameborder: "frameBorder",
        contenteditable: "contentEditable"
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem[sym__nodeType_];

        // don't get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery[sym__isXMLDoc_]( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery[sym__propFix_][ name ] || name;
            hooks = jQuery[sym__propHooks_][ name ];
        }

        if ( value !== undefined ) {
            if ( hooks && sym__set_ in hooks && (ret = hooks[sym__set_]( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                return ( elem[ name ] = value );
            }

        } else {
            if ( hooks && sym__get_ in hooks && (ret = hooks[sym__get_]( elem, name )) !== sym__g_null_ ) {
                return ret;

            } else {
                return elem[ name ];
            }
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                var attributeNode = elem[sym__getAttributeNode_]("tabindex");

                return attributeNode && attributeNode[sym__specified_] ?
                    parseInt( attributeNode[sym__value_], 10 ) :
                    rfocusable[sym__test_]( elem[sym__nodeName_] ) || rclickable[sym__test_]( elem[sym__nodeName_] ) && elem[sym__href_] ?
                        0 :
                        undefined;
            }
        }
    }
});

// Hook for boolean attributes
boolHook = {
    get: function( elem, name ) {
        // Align boolean attributes with corresponding properties
        // Fall back to attribute presence where some booleans are not supported
        var attrNode,
            property = jQuery[sym__prop_]( elem, name );
        return property === sym__g_true_ || typeof property !== sym__boolean_ && ( attrNode = elem[sym__getAttributeNode_](name) ) && attrNode[sym__nodeValue_] !== sym__g_false_ ?
            name[sym__toLowerCase_]() :
            undefined;
    },
    set: function( elem, value, name ) {
        var propName;
        if ( value === sym__g_false_ ) {
            // Remove boolean attributes when set to false
            jQuery[sym__removeAttr_]( elem, name );
        } else {
            // value is true since we know at this point it's type boolean and not false
            // Set boolean attributes to the same name and set the DOM property
            propName = jQuery[sym__propFix_][ name ] || name;
            if ( propName in elem ) {
                // Only set the IDL specifically if it already exists on the element
                elem[ propName ] = sym__g_true_;
            }

            elem[sym__setAttribute_]( name, name[sym__toLowerCase_]() );
        }
        return name;
    }
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

    fixSpecified = {
        name: sym__g_true_,
        id: sym__g_true_,
        coords: sym__g_true_
    };

    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = jQuery[sym__valHooks_][sym__button_] = {
        get: function( elem, name ) {
            var ret;
            ret = elem[sym__getAttributeNode_]( name );
            return ret && ( fixSpecified[ name ] ? ret[sym__value_] !== "" : ret[sym__specified_] ) ?
                ret[sym__value_] :
                undefined;
        },
        set: function( elem, value, name ) {
            // Set the existing or create a new attribute node
            var ret = elem[sym__getAttributeNode_]( name );
            if ( !ret ) {
                ret = document.createAttribute( name );
                elem.setAttributeNode( ret );
            }
            return ( ret[sym__value_] = value + "" );
        }
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery[sym__each_]([ sym__width_, sym__height_ ], function( i, name ) {
        jQuery[sym__attrHooks_][ name ] = jQuery[sym__extend_]( jQuery[sym__attrHooks_][ name ], {
            set: function( elem, value ) {
                if ( value === "" ) {
                    elem[sym__setAttribute_]( name, sym__auto_ );
                    return value;
                }
            }
        });
    });

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery[sym__attrHooks_].contenteditable = {
        get: nodeHook[sym__get_],
        set: function( elem, value, name ) {
            if ( value === "" ) {
                value = sym__false_;
            }
            nodeHook[sym__set_]( elem, value, name );
        }
    };
}


// Some attributes require a special call on IE
if ( !jQuery[sym__support_].hrefNormalized ) {
    jQuery[sym__each_]([ sym__href_, "src", sym__width_, sym__height_ ], function( i, name ) {
        jQuery[sym__attrHooks_][ name ] = jQuery[sym__extend_]( jQuery[sym__attrHooks_][ name ], {
            get: function( elem ) {
                var ret = elem[sym__getAttribute_]( name, 2 );
                return ret === sym__g_null_ ? undefined : ret;
            }
        });
    });
}

if ( !jQuery[sym__support_][sym__style_] ) {
    jQuery[sym__attrHooks_][sym__style_] = {
        get: function( elem ) {
            // Return undefined in the case of empty string
            // Normalize to lowercase since IE uppercases css property names
            return elem[sym__style_][sym__cssText_][sym__toLowerCase_]() || undefined;
        },
        set: function( elem, value ) {
            return ( elem[sym__style_][sym__cssText_] = value + "" );
        }
    };
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery[sym__support_].optSelected ) {
    jQuery[sym__propHooks_][sym__selected_] = jQuery[sym__extend_]( jQuery[sym__propHooks_][sym__selected_], {
        get: function( elem ) {
            var parent = elem[sym__parentNode_];

            if ( parent ) {
                parent[sym__selectedIndex_];

                // Make sure that it also works with optgroups, see #5701
                if ( parent[sym__parentNode_] ) {
                    parent[sym__parentNode_][sym__selectedIndex_];
                }
            }
            return sym__g_null_;
        }
    });
}

// IE6/7 call enctype encoding
if ( !jQuery[sym__support_][sym__enctype_] ) {
    jQuery[sym__propFix_][sym__enctype_] = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery[sym__support_].checkOn ) {
    jQuery[sym__each_]([ sym__radio_, sym__checkbox_ ], function() {
        jQuery[sym__valHooks_][ this ] = {
            get: function( elem ) {
                // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                return elem[sym__getAttribute_](sym__value_) === sym__g_null_ ? "on" : elem[sym__value_];
            }
        };
    });
}
jQuery[sym__each_]([ sym__radio_, sym__checkbox_ ], function() {
    jQuery[sym__valHooks_][ this ] = jQuery[sym__extend_]( jQuery[sym__valHooks_][ this ], {
        set: function( elem, value ) {
            if ( jQuery[sym__isArray_]( value ) ) {
                return ( elem[sym__checked_] = jQuery[sym__inArray_]( jQuery(elem).val(), value ) >= 0 );
            }
        }
    });
});
var rformElems = /^(?:textarea|input|select)$/i,
    rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
    rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    hoverHack = function( events ) {
        return jQuery[sym__event_][sym__special_].hover ? events : events[sym__replace_]( rhoverHack, "mouseenter$1 mouseleave$1" );
    };

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery[sym__event_] = {

    add: function( elem, types, handler, data, selector ) {

        var elemData, eventHandle, events,
            t, tns, type, namespaces, handleObj,
            handleObjIn, handlers, special;

        // Don't attach events to noData or text/comment nodes (allow plain objects tho)
        if ( elem[sym__nodeType_] === 3 || elem[sym__nodeType_] === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler[sym__handler_] ) {
            handleObjIn = handler;
            handler = handleObjIn[sym__handler_];
            selector = handleObjIn[sym__selector_];
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler[sym__guid_] ) {
            handler[sym__guid_] = jQuery[sym__guid_]++;
        }

        // Init the element's event structure and main handler, if this is the first
        events = elemData[sym__events_];
        if ( !events ) {
            elemData[sym__events_] = events = {};
        }
        eventHandle = elemData[sym__handle_];
        if ( !eventHandle ) {
            elemData[sym__handle_] = eventHandle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== sym__undefined_ && (!e || jQuery[sym__event_][sym__triggered_] !== e[sym__type_]) ?
                    jQuery[sym__event_][sym__dispatch_][sym__apply_]( eventHandle[sym__elem_], arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle[sym__elem_] = elem;
        }

        // Handle multiple events separated by a space
        // jQuery(...).bind("mouseover mouseout", fn);
        types = jQuery[sym__trim_]( hoverHack(types) )[sym__split_]( " " );
        for ( t = 0; t < types[sym__length_]; t++ ) {

            tns = rtypenamespace[sym__exec_]( types[t] ) || [];
            type = tns[1];
            namespaces = ( tns[2] || "" )[sym__split_]( "." )[sym__sort_]();

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery[sym__event_][sym__special_][ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special[sym__delegateType_] : special[sym__bindType_] ) || type;

            // Update special based on newly reset type
            special = jQuery[sym__event_][sym__special_][ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery[sym__extend_]({
                type: type,
                origType: tns[1],
                data: data,
                handler: handler,
                guid: handler[sym__guid_],
                selector: selector,
                needsContext: selector && jQuery[sym__expr_].match[sym__needsContext_][sym__test_]( selector ),
                namespace: namespaces[sym__join_](".")
            }, handleObjIn );

            // Init the event handler queue if we're the first
            handlers = events[ type ];
            if ( !handlers ) {
                handlers = events[ type ] = [];
                handlers[sym__delegateCount_] = 0;

                // Only use addEventListener/attachEvent if the special events handler returns false
                if ( !special.setup || special.setup[sym__call_]( elem, data, namespaces, eventHandle ) === sym__g_false_ ) {
                    // Bind the global event handler to the element
                    if ( elem[sym__addEventListener_] ) {
                        elem[sym__addEventListener_]( type, eventHandle, sym__g_false_ );

                    } else if ( elem[sym__attachEvent_] ) {
                        elem[sym__attachEvent_]( sym__on_ + type, eventHandle );
                    }
                }
            }

            if ( special[sym__add_] ) {
                special[sym__add_][sym__call_]( elem, handleObj );

                if ( !handleObj[sym__handler_][sym__guid_] ) {
                    handleObj[sym__handler_][sym__guid_] = handler[sym__guid_];
                }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
                handlers[sym__splice_]( handlers[sym__delegateCount_]++, 0, handleObj );
            } else {
                handlers[sym__push_]( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery[sym__event_][sym__global_][ type ] = sym__g_true_;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = sym__g_null_;
    },

    global: {},

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {

        var t, tns, type, origType, namespaces, origCount,
            j, events, special, eventType, handleObj,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem );

        if ( !elemData || !(events = elemData[sym__events_]) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = jQuery[sym__trim_]( hoverHack( types || "" ) )[sym__split_](" ");
        for ( t = 0; t < types[sym__length_]; t++ ) {
            tns = rtypenamespace[sym__exec_]( types[t] ) || [];
            type = origType = tns[1];
            namespaces = tns[2];

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery[sym__event_][sym__remove_]( elem, type + types[ t ], handler, selector, sym__g_true_ );
                }
                continue;
            }

            special = jQuery[sym__event_][sym__special_][ type ] || {};
            type = ( selector? special[sym__delegateType_] : special[sym__bindType_] ) || type;
            eventType = events[ type ] || [];
            origCount = eventType[sym__length_];
            namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces[sym__split_](".")[sym__sort_]()[sym__join_]("\\.(?:.*\\.|)") + "(\\.|$)") : sym__g_null_;

            // Remove matching events
            for ( j = 0; j < eventType[sym__length_]; j++ ) {
                handleObj = eventType[ j ];

                if ( ( mappedTypes || origType === handleObj[sym__origType_] ) &&
                     ( !handler || handler[sym__guid_] === handleObj[sym__guid_] ) &&
                     ( !namespaces || namespaces[sym__test_]( handleObj[sym__namespace_] ) ) &&
                     ( !selector || selector === handleObj[sym__selector_] || selector === "**" && handleObj[sym__selector_] ) ) {
                    eventType[sym__splice_]( j--, 1 );

                    if ( handleObj[sym__selector_] ) {
                        eventType[sym__delegateCount_]--;
                    }
                    if ( special[sym__remove_] ) {
                        special[sym__remove_][sym__call_]( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( eventType[sym__length_] === 0 && origCount !== eventType[sym__length_] ) {
                if ( !special.teardown || special.teardown[sym__call_]( elem, namespaces, elemData[sym__handle_] ) === sym__g_false_ ) {
                    jQuery[sym__removeEvent_]( elem, type, elemData[sym__handle_] );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery[sym__isEmptyObject_]( events ) ) {
            delete elemData[sym__handle_];

            // removeData also checks for emptiness and clears the expando if empty
            // so use it instead of delete
            jQuery[sym__removeData_]( elem, sym__events_, sym__g_true_ );
        }
    },

    // Events that are safe to short-circuit if no handlers are attached.
    // Native DOM events should not be added, they may have inline handlers.
    customEvent: {
        "getData": sym__g_true_,
        "setData": sym__g_true_,
        "changeData": sym__g_true_
    },

    trigger: function( event, data, elem, onlyHandlers ) {
        // Don't do events on text and comment nodes
        if ( elem && (elem[sym__nodeType_] === 3 || elem[sym__nodeType_] === 8) ) {
            return;
        }

        // Event object or event type
        var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
            type = event[sym__type_] || event,
            namespaces = [];

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if ( rfocusMorph[sym__test_]( type + jQuery[sym__event_][sym__triggered_] ) ) {
            return;
        }

        if ( type[sym__indexOf_]( "!" ) >= 0 ) {
            // Exclusive events trigger only for the exact event (no namespaces)
            type = type[sym__slice_](0, -1);
            exclusive = sym__g_true_;
        }

        if ( type[sym__indexOf_]( "." ) >= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type[sym__split_](".");
            type = namespaces[sym__shift_]();
            namespaces[sym__sort_]();
        }

        if ( (!elem || jQuery[sym__event_].customEvent[ type ]) && !jQuery[sym__event_][sym__global_][ type ] ) {
            // No jQuery handlers for this event type, and it can't have inline handlers
            return;
        }

        // Caller can pass in an Event, Object, or just an event type string
        event = typeof event === sym__object_ ?
            // jQuery.Event object
            event[ jQuery[sym__expando_] ] ? event :
            // Object literal
            new jQuery[sym__Event_]( type, event ) :
            // Just the event type (string)
            new jQuery[sym__Event_]( type );

        event[sym__type_] = type;
        event[sym__isTrigger_] = sym__g_true_;
        event[sym__exclusive_] = exclusive;
        event[sym__namespace_] = namespaces[sym__join_]( "." );
        event.namespace_re = event[sym__namespace_]? new RegExp("(^|\\.)" + namespaces[sym__join_]("\\.(?:.*\\.|)") + "(\\.|$)") : sym__g_null_;
        ontype = type[sym__indexOf_]( ":" ) < 0 ? sym__on_ + type : "";

        // Handle a global trigger
        if ( !elem ) {

            // TODO: Stop taunting the data cache; remove global events and always attach to document
            cache = jQuery[sym__cache_];
            for ( i in cache ) {
                if ( cache[ i ][sym__events_] && cache[ i ][sym__events_][ type ] ) {
                    jQuery[sym__event_][sym__trigger_]( event, data, cache[ i ][sym__handle_][sym__elem_], sym__g_true_ );
                }
            }
            return;
        }

        // Clean up the event in case it is being reused
        event[sym__result_] = undefined;
        if ( !event[sym__target_] ) {
            event[sym__target_] = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data != sym__g_null_ ? jQuery[sym__makeArray_]( data ) : [];
        data[sym__unshift_]( event );

        // Allow special events to draw outside the lines
        special = jQuery[sym__event_][sym__special_][ type ] || {};
        if ( special[sym__trigger_] && special[sym__trigger_][sym__apply_]( elem, data ) === sym__g_false_ ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        eventPath = [[ elem, special[sym__bindType_] || type ]];
        if ( !onlyHandlers && !special.noBubble && !jQuery[sym__isWindow_]( elem ) ) {

            bubbleType = special[sym__delegateType_] || type;
            cur = rfocusMorph[sym__test_]( bubbleType + type ) ? elem : elem[sym__parentNode_];
            for ( old = elem; cur; cur = cur[sym__parentNode_] ) {
                eventPath[sym__push_]([ cur, bubbleType ]);
                old = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( old === (elem[sym__ownerDocument_] || document) ) {
                eventPath[sym__push_]([ old[sym__defaultView_] || old[sym__parentWindow_] || sym__g_window_, bubbleType ]);
            }
        }

        // Fire handlers on the event path
        for ( i = 0; i < eventPath[sym__length_] && !event[sym__isPropagationStopped_](); i++ ) {

            cur = eventPath[i][0];
            event[sym__type_] = eventPath[i][1];

            handle = ( jQuery._data( cur, sym__events_ ) || {} )[ event[sym__type_] ] && jQuery._data( cur, sym__handle_ );
            if ( handle ) {
                handle[sym__apply_]( cur, data );
            }
            // Note that this is a bare JS function and not a jQuery handler
            handle = ontype && cur[ ontype ];
            if ( handle && jQuery[sym__acceptData_]( cur ) && handle[sym__apply_] && handle[sym__apply_]( cur, data ) === sym__g_false_ ) {
                event[sym__preventDefault_]();
            }
        }
        event[sym__type_] = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers && !event[sym__isDefaultPrevented_]() ) {

            if ( (!special._default || special._default[sym__apply_]( elem[sym__ownerDocument_], data ) === sym__g_false_) &&
                !(type === sym__click_ && jQuery[sym__nodeName_]( elem, "a" )) && jQuery[sym__acceptData_]( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Can't use an .isFunction() check here because IE6/7 fails that test.
                // Don't do default actions on window, that's where global variables be (#6170)
                // IE<9 dies on focus/blur to hidden element (#1486)
                if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event[sym__target_][sym__offsetWidth_] !== 0) && !jQuery[sym__isWindow_]( elem ) ) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    old = elem[ ontype ];

                    if ( old ) {
                        elem[ ontype ] = sym__g_null_;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery[sym__event_][sym__triggered_] = type;
                    elem[ type ]();
                    jQuery[sym__event_][sym__triggered_] = undefined;

                    if ( old ) {
                        elem[ ontype ] = old;
                    }
                }
            }
        }

        return event[sym__result_];
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery[sym__event_].fix( event || sym__g_window_[sym__event_] );

        var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
            handlers = ( (jQuery._data( this, sym__events_ ) || {} )[ event[sym__type_] ] || []),
            delegateCount = handlers[sym__delegateCount_],
            args = core_slice[sym__call_]( arguments ),
            run_all = !event[sym__exclusive_] && !event[sym__namespace_],
            special = jQuery[sym__event_][sym__special_][ event[sym__type_] ] || {},
            handlerQueue = [];

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event[sym__delegateTarget_] = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special[sym__preDispatch_] && special[sym__preDispatch_][sym__call_]( this, event ) === sym__g_false_ ) {
            return;
        }

        // Determine handlers that should run if there are delegated events
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount && !(event[sym__button_] && event[sym__type_] === sym__click_) ) {

            for ( cur = event[sym__target_]; cur != this; cur = cur[sym__parentNode_] || this ) {

                // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur[sym__disabled_] !== sym__g_true_ || event[sym__type_] !== sym__click_ ) {
                    selMatch = {};
                    matches = [];
                    for ( i = 0; i < delegateCount; i++ ) {
                        handleObj = handlers[ i ];
                        sel = handleObj[sym__selector_];

                        if ( selMatch[ sel ] === undefined ) {
                            selMatch[ sel ] = handleObj[sym__needsContext_] ?
                                jQuery( sel, this )[sym__index_]( cur ) >= 0 :
                                jQuery[sym__find_]( sel, this, sym__g_null_, [ cur ] )[sym__length_];
                        }
                        if ( selMatch[ sel ] ) {
                            matches[sym__push_]( handleObj );
                        }
                    }
                    if ( matches[sym__length_] ) {
                        handlerQueue[sym__push_]({ elem: cur, matches: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( handlers[sym__length_] > delegateCount ) {
            handlerQueue[sym__push_]({ elem: this, matches: handlers[sym__slice_]( delegateCount ) });
        }

        // Run delegates first; they may want to stop propagation beneath us
        for ( i = 0; i < handlerQueue[sym__length_] && !event[sym__isPropagationStopped_](); i++ ) {
            matched = handlerQueue[ i ];
            event.currentTarget = matched[sym__elem_];

            for ( j = 0; j < matched[sym__matches_][sym__length_] && !event[sym__isImmediatePropagationStopped_](); j++ ) {
                handleObj = matched[sym__matches_][ j ];

                // Triggered event must either 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( run_all || (!event[sym__namespace_] && !handleObj[sym__namespace_]) || event.namespace_re && event.namespace_re[sym__test_]( handleObj[sym__namespace_] ) ) {

                    event[sym__data_] = handleObj[sym__data_];
                    event[sym__handleObj_] = handleObj;

                    ret = ( (jQuery[sym__event_][sym__special_][ handleObj[sym__origType_] ] || {})[sym__handle_] || handleObj[sym__handler_] )
                            [sym__apply_]( matched[sym__elem_], args );

                    if ( ret !== undefined ) {
                        event[sym__result_] = ret;
                        if ( ret === sym__g_false_ ) {
                            event[sym__preventDefault_]();
                            event[sym__stopPropagation_]();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special[sym__postDispatch_] ) {
            special[sym__postDispatch_][sym__call_]( this, event );
        }

        return event[sym__result_];
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
    props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which"[sym__split_](" "),

    fixHooks: {},

    keyHooks: {
        props: "char charCode key keyCode"[sym__split_](" "),
        filter: function( event, original ) {

            // Add which for key events
            if ( event[sym__which_] == sym__g_null_ ) {
                event[sym__which_] = original.charCode != sym__g_null_ ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement"[sym__split_](" "),
        filter: function( event, original ) {
            var eventDoc, doc, body,
                button = original[sym__button_],
                fromElement = original.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == sym__g_null_ && original.clientX != sym__g_null_ ) {
                eventDoc = event[sym__target_][sym__ownerDocument_] || document;
                doc = eventDoc[sym__documentElement_];
                body = eventDoc[sym__body_];

                event.pageX = original.clientX + ( doc && doc[sym__scrollLeft_] || body && body[sym__scrollLeft_] || 0 ) - ( doc && doc[sym__clientLeft_] || body && body[sym__clientLeft_] || 0 );
                event.pageY = original.clientY + ( doc && doc[sym__scrollTop_]  || body && body[sym__scrollTop_]  || 0 ) - ( doc && doc[sym__clientTop_]  || body && body[sym__clientTop_]  || 0 );
            }

            // Add relatedTarget, if necessary
            if ( !event[sym__relatedTarget_] && fromElement ) {
                event[sym__relatedTarget_] = fromElement === event[sym__target_] ? original.toElement : fromElement;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event[sym__which_] && button !== undefined ) {
                event[sym__which_] = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },

    fix: function( event ) {
        if ( event[ jQuery[sym__expando_] ] ) {
            return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop,
            originalEvent = event,
            fixHook = jQuery[sym__event_][sym__fixHooks_][ event[sym__type_] ] || {},
            copy = fixHook[sym__props_] ? this[sym__props_][sym__concat_]( fixHook[sym__props_] ) : this[sym__props_];

        event = jQuery[sym__Event_]( originalEvent );

        for ( i = copy[sym__length_]; i; ) {
            prop = copy[ --i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
        if ( !event[sym__target_] ) {
            event[sym__target_] = originalEvent.srcElement || document;
        }

        // Target should not be a text node (#504, Safari)
        if ( event[sym__target_][sym__nodeType_] === 3 ) {
            event[sym__target_] = event[sym__target_][sym__parentNode_];
        }

        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
        event.metaKey = !!event.metaKey;

        return fixHook[sym__filter_]? fixHook[sym__filter_]( event, originalEvent ) : event;
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: sym__g_true_
        },

        focus: {
            delegateType: "focusin"
        },
        blur: {
            delegateType: "focusout"
        },

        beforeunload: {
            setup: function( data, namespaces, eventHandle ) {
                // We only want to do this special case on windows
                if ( jQuery[sym__isWindow_]( this ) ) {
                    this[sym__onbeforeunload_] = eventHandle;
                }
            },

            teardown: function( namespaces, eventHandle ) {
                if ( this[sym__onbeforeunload_] === eventHandle ) {
                    this[sym__onbeforeunload_] = sym__g_null_;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery[sym__extend_](
            new jQuery[sym__Event_](),
            event,
            { type: type,
                isSimulated: sym__g_true_,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery[sym__event_][sym__trigger_]( e, sym__g_null_, elem );
        } else {
            jQuery[sym__event_][sym__dispatch_][sym__call_]( elem, e );
        }
        if ( e[sym__isDefaultPrevented_]() ) {
            event[sym__preventDefault_]();
        }
    }
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery[sym__event_][sym__handle_] = jQuery[sym__event_][sym__dispatch_];

jQuery[sym__removeEvent_] = document[sym__removeEventListener_] ?
    function( elem, type, handle ) {
        if ( elem[sym__removeEventListener_] ) {
            elem[sym__removeEventListener_]( type, handle, sym__g_false_ );
        }
    } :
    function( elem, type, handle ) {
        var name = sym__on_ + type;

        if ( elem[sym__detachEvent_] ) {

            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if ( typeof elem[ name ] === sym__undefined_ ) {
                elem[ name ] = sym__g_null_;
            }

            elem[sym__detachEvent_]( name, handle );
        }
    };

jQuery[sym__Event_] = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof jQuery[sym__Event_]) ) {
        return new jQuery[sym__Event_]( src, props );
    }

    // Event object
    if ( src && src[sym__type_] ) {
        this[sym__originalEvent_] = src;
        this[sym__type_] = src[sym__type_];

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this[sym__isDefaultPrevented_] = ( src.defaultPrevented || src[sym__returnValue_] === sym__g_false_ ||
            src[sym__getPreventDefault_] && src[sym__getPreventDefault_]() ) ? returnTrue : returnFalse;

    // Event type
    } else {
        this[sym__type_] = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery[sym__extend_]( this, props );
    }

    // Create a timestamp if incoming event doesn't have one
    this[sym__timeStamp_] = src && src[sym__timeStamp_] || jQuery[sym__now_]();

    // Mark it as fixed
    this[ jQuery[sym__expando_] ] = sym__g_true_;
};

function returnFalse() {
    return sym__g_false_;
}
function returnTrue() {
    return sym__g_true_;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery[sym__Event_][sym__prototype_] = {
    preventDefault: function() {
        this[sym__isDefaultPrevented_] = returnTrue;

        var e = this[sym__originalEvent_];
        if ( !e ) {
            return;
        }

        // if preventDefault exists run it on the original event
        if ( e[sym__preventDefault_] ) {
            e[sym__preventDefault_]();

        // otherwise set the returnValue property of the original event to false (IE)
        } else {
            e[sym__returnValue_] = sym__g_false_;
        }
    },
    stopPropagation: function() {
        this[sym__isPropagationStopped_] = returnTrue;

        var e = this[sym__originalEvent_];
        if ( !e ) {
            return;
        }
        // if stopPropagation exists run it on the original event
        if ( e[sym__stopPropagation_] ) {
            e[sym__stopPropagation_]();
        }
        // otherwise set the cancelBubble property of the original event to true (IE)
        e.cancelBubble = sym__g_true_;
    },
    stopImmediatePropagation: function() {
        this[sym__isImmediatePropagationStopped_] = returnTrue;
        this[sym__stopPropagation_]();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery[sym__each_]({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
}, function( orig, fix ) {
    jQuery[sym__event_][sym__special_][ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event[sym__relatedTarget_],
                handleObj = event[sym__handleObj_],
                selector = handleObj[sym__selector_];

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !jQuery[sym__contains_]( target, related )) ) {
                event[sym__type_] = handleObj[sym__origType_];
                ret = handleObj[sym__handler_][sym__apply_]( this, arguments );
                event[sym__type_] = fix;
            }
            return ret;
        }
    };
});

// IE submit delegation
if ( !jQuery[sym__support_].submitBubbles ) {

    jQuery[sym__event_][sym__special_][sym__submit_] = {
        setup: function() {
            // Only need this for delegated form submit events
            if ( jQuery[sym__nodeName_]( this, sym__form_ ) ) {
                return sym__g_false_;
            }

            // Lazy-add a submit handler when a descendant form may potentially be submitted
            jQuery[sym__event_][sym__add_]( this, "click._submit keypress._submit", function( e ) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e[sym__target_],
                    form = jQuery[sym__nodeName_]( elem, sym__input_ ) || jQuery[sym__nodeName_]( elem, sym__button_ ) ? elem[sym__form_] : undefined;
                if ( form && !jQuery._data( form, "_submit_attached" ) ) {
                    jQuery[sym__event_][sym__add_]( form, "submit._submit", function( event ) {
                        event._submit_bubble = sym__g_true_;
                    });
                    jQuery._data( form, "_submit_attached", sym__g_true_ );
                }
            });
            // return undefined since we don't need an event listener
        },

        postDispatch: function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( event._submit_bubble ) {
                delete event._submit_bubble;
                if ( this[sym__parentNode_] && !event[sym__isTrigger_] ) {
                    jQuery[sym__event_][sym__simulate_]( sym__submit_, this[sym__parentNode_], event, sym__g_true_ );
                }
            }
        },

        teardown: function() {
            // Only need this for delegated form submit events
            if ( jQuery[sym__nodeName_]( this, sym__form_ ) ) {
                return sym__g_false_;
            }

            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            jQuery[sym__event_][sym__remove_]( this, "._submit" );
        }
    };
}

// IE change delegation and checkbox/radio fix
if ( !jQuery[sym__support_].changeBubbles ) {

    jQuery[sym__event_][sym__special_][sym__change_] = {

        setup: function() {

            if ( rformElems[sym__test_]( this[sym__nodeName_] ) ) {
                // IE doesn't fire change on a check/radio until blur; trigger it on click
                // after a propertychange. Eat the blur-change in special.change.handle.
                // This still fires onchange a second time for check/radio after blur.
                if ( this[sym__type_] === sym__checkbox_ || this[sym__type_] === sym__radio_ ) {
                    jQuery[sym__event_][sym__add_]( this, "propertychange._change", function( event ) {
                        if ( event[sym__originalEvent_].propertyName === sym__checked_ ) {
                            this._just_changed = sym__g_true_;
                        }
                    });
                    jQuery[sym__event_][sym__add_]( this, "click._change", function( event ) {
                        if ( this._just_changed && !event[sym__isTrigger_] ) {
                            this._just_changed = sym__g_false_;
                        }
                        // Allow triggered, simulated change events (#11500)
                        jQuery[sym__event_][sym__simulate_]( sym__change_, this, event, sym__g_true_ );
                    });
                }
                return sym__g_false_;
            }
            // Delegated event; lazy-add a change handler on descendant inputs
            jQuery[sym__event_][sym__add_]( this, "beforeactivate._change", function( e ) {
                var elem = e[sym__target_];

                if ( rformElems[sym__test_]( elem[sym__nodeName_] ) && !jQuery._data( elem, "_change_attached" ) ) {
                    jQuery[sym__event_][sym__add_]( elem, "change._change", function( event ) {
                        if ( this[sym__parentNode_] && !event[sym__isSimulated_] && !event[sym__isTrigger_] ) {
                            jQuery[sym__event_][sym__simulate_]( sym__change_, this[sym__parentNode_], event, sym__g_true_ );
                        }
                    });
                    jQuery._data( elem, "_change_attached", sym__g_true_ );
                }
            });
        },

        handle: function( event ) {
            var elem = event[sym__target_];

            // Swallow native change events from checkbox/radio, we already triggered them above
            if ( this !== elem || event[sym__isSimulated_] || event[sym__isTrigger_] || (elem[sym__type_] !== sym__radio_ && elem[sym__type_] !== sym__checkbox_) ) {
                return event[sym__handleObj_][sym__handler_][sym__apply_]( this, arguments );
            }
        },

        teardown: function() {
            jQuery[sym__event_][sym__remove_]( this, "._change" );

            return !rformElems[sym__test_]( this[sym__nodeName_] );
        }
    };
}

// Create "bubbling" focus and blur events
if ( !jQuery[sym__support_].focusinBubbles ) {
    jQuery[sym__each_]({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

        // Attach a single capturing handler while someone wants focusin/focusout
        var attaches = 0,
            handler = function( event ) {
                jQuery[sym__event_][sym__simulate_]( fix, event[sym__target_], jQuery[sym__event_].fix( event ), sym__g_true_ );
            };

        jQuery[sym__event_][sym__special_][ fix ] = {
            setup: function() {
                if ( attaches++ === 0 ) {
                    document[sym__addEventListener_]( orig, handler, sym__g_true_ );
                }
            },
            teardown: function() {
                if ( --attaches === 0 ) {
                    document[sym__removeEventListener_]( orig, handler, sym__g_true_ );
                }
            }
        };
    });
}

jQuery[sym__fn_][sym__extend_]({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var origFn, type;

        // Types can be a map of types/handlers
        if ( typeof types === sym__object_ ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== sym__string_ ) { // && selector != null
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this[sym__on_]( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == sym__g_null_ && fn == sym__g_null_ ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == sym__g_null_ ) {
            if ( typeof selector === sym__string_ ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === sym__g_false_ ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery()[sym__off_]( event );
                return origFn[sym__apply_]( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn[sym__guid_] = origFn[sym__guid_] || ( origFn[sym__guid_] = jQuery[sym__guid_]++ );
        }
        return this[sym__each_]( function() {
            jQuery[sym__event_][sym__add_]( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this[sym__on_]( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types && types[sym__preventDefault_] && types[sym__handleObj_] ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types[sym__handleObj_];
            jQuery( types[sym__delegateTarget_] )[sym__off_](
                handleObj[sym__namespace_] ? handleObj[sym__origType_] + "." + handleObj[sym__namespace_] : handleObj[sym__origType_],
                handleObj[sym__selector_],
                handleObj[sym__handler_]
            );
            return this;
        }
        if ( typeof types === sym__object_ ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this[sym__off_]( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === sym__g_false_ || typeof selector === sym__function_ ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === sym__g_false_ ) {
            fn = returnFalse;
        }
        return this[sym__each_](function() {
            jQuery[sym__event_][sym__remove_]( this, types, fn, selector );
        });
    },

    bind: function( types, data, fn ) {
        return this[sym__on_]( types, sym__g_null_, data, fn );
    },
    unbind: function( types, fn ) {
        return this[sym__off_]( types, sym__g_null_, fn );
    },

    live: function( types, data, fn ) {
        jQuery( this[sym__context_] )[sym__on_]( types, this[sym__selector_], data, fn );
        return this;
    },
    die: function( types, fn ) {
        jQuery( this[sym__context_] )[sym__off_]( types, this[sym__selector_] || "**", fn );
        return this;
    },

    delegate: function( selector, types, data, fn ) {
        return this[sym__on_]( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments[sym__length_] === 1 ? this[sym__off_]( selector, "**" ) : this[sym__off_]( types, selector || "**", fn );
    },

    trigger: function( type, data ) {
        return this[sym__each_](function() {
            jQuery[sym__event_][sym__trigger_]( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        if ( this[0] ) {
            return jQuery[sym__event_][sym__trigger_]( type, data, this[0], sym__g_true_ );
        }
    },

    toggle: function( fn ) {
        // Save reference to arguments for access in closure
        var args = arguments,
            guid = fn[sym__guid_] || jQuery[sym__guid_]++,
            i = 0,
            toggler = function( event ) {
                // Figure out which function to execute
                var lastToggle = ( jQuery._data( this, sym__lastToggle_ + fn[sym__guid_] ) || 0 ) % i;
                jQuery._data( this, sym__lastToggle_ + fn[sym__guid_], lastToggle + 1 );

                // Make sure that clicks stop
                event[sym__preventDefault_]();

                // and execute the function
                return args[ lastToggle ][sym__apply_]( this, arguments ) || sym__g_false_;
            };

        // link all the functions, so any of them can unbind this click handler
        toggler[sym__guid_] = guid;
        while ( i < args[sym__length_] ) {
            args[ i++ ][sym__guid_] = guid;
        }

        return this[sym__click_]( toggler );
    },

    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    }
});

jQuery[sym__each_]( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu")[sym__split_](" "), function( i, name ) {

    // Handle event binding
    jQuery[sym__fn_][ name ] = function( data, fn ) {
        if ( fn == sym__g_null_ ) {
            fn = data;
            data = sym__g_null_;
        }

        return arguments[sym__length_] > 0 ?
            this[sym__on_]( name, sym__g_null_, data, fn ) :
            this[sym__trigger_]( name );
    };

    if ( rkeyEvent[sym__test_]( name ) ) {
        jQuery[sym__event_][sym__fixHooks_][ name ] = jQuery[sym__event_].keyHooks;
    }

    if ( rmouseEvent[sym__test_]( name ) ) {
        jQuery[sym__event_][sym__fixHooks_][ name ] = jQuery[sym__event_].mouseHooks;
    }
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( sym__g_window_, undefined ) {

var cachedruns,
    assertGetIdNotName,
    Expr,
    getText,
    isXML,
    contains,
    compile,
    sortOrder,
    hasDuplicate,
    outermostContext,

    baseHasDuplicate = sym__g_true_,
    strundefined = sym__undefined_,

    expando = ( "sizcache" + Math.random() )[sym__replace_]( ".", "" ),

    Token = String,
    document = sym__g_window_[sym__document_],
    docElem = document[sym__documentElement_],
    dirruns = 0,
    done = 0,
    pop = [].pop,
    push = [][sym__push_],
    slice = [][sym__slice_],
    // Use a stripped-down indexOf if a native one is unavailable
    indexOf = [][sym__indexOf_] || function( elem ) {
        var i = 0,
            len = this[sym__length_];
        for ( ; i < len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    // Augment a function for special use by Sizzle
    markFunction = function( fn, value ) {
        fn[ expando ] = value == sym__g_null_ || value;
        return fn;
    },

    createCache = function() {
        var cache = {},
            keys = [];

        return markFunction(function( key, value ) {
            // Only keep the most recent entries
            if ( keys[sym__push_]( key ) > Expr.cacheLength ) {
                delete cache[ keys[sym__shift_]() ];
            }

            // Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
            return (cache[ key + " " ] = value);
        }, cache );
    },

    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),

    // Regex

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding[sym__replace_]( "w", "w#" ),

    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    operators = "([*^$|!~]?=)",
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
        "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

    // Prefer arguments not in parens/brackets,
    //   then attribute selectors and non-pseudos (denoted by :),
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

    // For matchExpr.POS and matchExpr.needsContext
    pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
        "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
    rpseudo = new RegExp( pseudos ),

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

    rnot = /^:not/,
    rsibling = /[\x20\t\r\n\f]*[+~]/,
    rendsWithNot = /:not\($/,

    rheader = /h\d/i,
    rinputs = /input|select|textarea|button/i,

    rbackslash = /\\(?!\\)/g,

    matchExpr = {
        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
        "NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
        "TAG": new RegExp( "^(" + characterEncoding[sym__replace_]( "w", "w*" ) + ")" ),
        "ATTR": new RegExp( "^" + attributes ),
        "PSEUDO": new RegExp( "^" + pseudos ),
        "POS": new RegExp( pos, "i" ),
        "CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
        // For use in libraries implementing .is()
        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
    },

    // Support

    // Used for testing something on an element
    assert = function( fn ) {
        var div = document[sym__createElement_](sym__div_);

        try {
            return fn( div );
        } catch (e) {
            return sym__g_false_;
        } finally {
            // release memory in IE
            div = sym__g_null_;
        }
    },

    // Check if getElementsByTagName("*") returns only elements
    assertTagNameNoComments = assert(function( div ) {
        div[sym__appendChild_]( document.createComment("") );
        return !div[sym__getElementsByTagName_]("*")[sym__length_];
    }),

    // Check if getAttribute returns normalized href attributes
    assertHrefNotNormalized = assert(function( div ) {
        div[sym__innerHTML_] = "<a href='#'></a>";
        return div[sym__firstChild_] && typeof div[sym__firstChild_][sym__getAttribute_] !== strundefined &&
            div[sym__firstChild_][sym__getAttribute_](sym__href_) === "#";
    }),

    // Check if attributes should be retrieved by attribute nodes
    assertAttributes = assert(function( div ) {
        div[sym__innerHTML_] = "<select></select>";
        var type = typeof div[sym__lastChild_][sym__getAttribute_]("multiple");
        // IE8 returns a string for some attributes even when not present
        return type !== sym__boolean_ && type !== sym__string_;
    }),

    // Check if getElementsByClassName can be trusted
    assertUsableClassName = assert(function( div ) {
        // Opera can't find a second classname (in 9.6)
        div[sym__innerHTML_] = "<div class='hidden e'></div><div class='hidden'></div>";
        if ( !div[sym__getElementsByClassName_] || !div[sym__getElementsByClassName_]("e")[sym__length_] ) {
            return sym__g_false_;
        }

        // Safari 3.2 caches class attributes and doesn't catch changes
        div[sym__lastChild_][sym__className_] = "e";
        return div[sym__getElementsByClassName_]("e")[sym__length_] === 2;
    }),

    // Check if getElementById returns elements by name
    // Check if getElementsByName privileges form controls or returns elements by ID
    assertUsableName = assert(function( div ) {
        // Inject content
        div[sym__id_] = expando + 0;
        div[sym__innerHTML_] = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
        docElem[sym__insertBefore_]( div, docElem[sym__firstChild_] );

        // Test
        var pass = document[sym__getElementsByName_] &&
            // buggy browsers will return fewer than the correct 2
            document[sym__getElementsByName_]( expando )[sym__length_] === 2 +
            // buggy browsers will return more than the correct 0
            document[sym__getElementsByName_]( expando + 0 )[sym__length_];
        assertGetIdNotName = !document[sym__getElementById_]( expando );

        // Cleanup
        docElem[sym__removeChild_]( div );

        return pass;
    });

// If slice is not available, provide a backup
try {
    slice[sym__call_]( docElem[sym__childNodes_], 0 )[0][sym__nodeType_];
} catch ( e ) {
    slice = function( i ) {
        var elem,
            results = [];
        for ( ; (elem = this[i]); i++ ) {
            results[sym__push_]( elem );
        }
        return results;
    };
}

function Sizzle( selector, context, results, seed ) {
    results = results || [];
    context = context || document;
    var match, elem, xml, m,
        nodeType = context[sym__nodeType_];

    if ( !selector || typeof selector !== sym__string_ ) {
        return results;
    }

    if ( nodeType !== 1 && nodeType !== 9 ) {
        return [];
    }

    xml = isXML( context );

    if ( !xml && !seed ) {
        if ( (match = rquickExpr[sym__exec_]( selector )) ) {
            // Speed-up: Sizzle("#ID")
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context[sym__getElementById_]( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem[sym__parentNode_] ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem[sym__id_] === m ) {
                            results[sym__push_]( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context[sym__ownerDocument_] && (elem = context[sym__ownerDocument_][sym__getElementById_]( m )) &&
                        contains( context, elem ) && elem[sym__id_] === m ) {
                        results[sym__push_]( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle("TAG")
            } else if ( match[2] ) {
                push[sym__apply_]( results, slice[sym__call_](context[sym__getElementsByTagName_]( selector ), 0) );
                return results;

            // Speed-up: Sizzle(".CLASS")
            } else if ( (m = match[3]) && assertUsableClassName && context[sym__getElementsByClassName_] ) {
                push[sym__apply_]( results, slice[sym__call_](context[sym__getElementsByClassName_]( m ), 0) );
                return results;
            }
        }
    }

    // All others
    return select( selector[sym__replace_]( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle[sym__matches_] = function( expr, elements ) {
    return Sizzle( expr, sym__g_null_, sym__g_null_, elements );
};

Sizzle[sym__matchesSelector_] = function( elem, expr ) {
    return Sizzle( expr, sym__g_null_, sym__g_null_, [ elem ] )[sym__length_] > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem[sym__nodeName_][sym__toLowerCase_]();
        return name === sym__input_ && elem[sym__type_] === type;
    };
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem[sym__nodeName_][sym__toLowerCase_]();
        return (name === sym__input_ || name === sym__button_) && elem[sym__type_] === type;
    };
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed[sym__length_], argument ),
                i = matchIndexes[sym__length_];

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem[sym__nodeType_];

    if ( nodeType ) {
        if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
            // Use textContent for elements
            // innerText usage removed for consistency of new lines (see #11153)
            if ( typeof elem[sym__textContent_] === sym__string_ ) {
                return elem[sym__textContent_];
            } else {
                // Traverse its children
                for ( elem = elem[sym__firstChild_]; elem; elem = elem[sym__nextSibling_] ) {
                    ret += getText( elem );
                }
            }
        } else if ( nodeType === 3 || nodeType === 4 ) {
            return elem[sym__nodeValue_];
        }
        // Do not include comment or processing instruction nodes
    } else {

        // If no nodeType, this is expected to be an array
        for ( ; (node = elem[i]); i++ ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    }
    return ret;
};

isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem[sym__ownerDocument_] || elem)[sym__documentElement_];
    return documentElement ? documentElement[sym__nodeName_] !== "HTML" : sym__g_false_;
};

// Element contains another
contains = Sizzle[sym__contains_] = docElem[sym__contains_] ?
    function( a, b ) {
        var adown = a[sym__nodeType_] === 9 ? a[sym__documentElement_] : a,
            bup = b && b[sym__parentNode_];
        return a === bup || !!( bup && bup[sym__nodeType_] === 1 && adown[sym__contains_] && adown[sym__contains_](bup) );
    } :
    docElem[sym__compareDocumentPosition_] ?
    function( a, b ) {
        return b && !!( a[sym__compareDocumentPosition_]( b ) & 16 );
    } :
    function( a, b ) {
        while ( (b = b[sym__parentNode_]) ) {
            if ( b === a ) {
                return sym__g_true_;
            }
        }
        return sym__g_false_;
    };

Sizzle[sym__attr_] = function( elem, name ) {
    var val,
        xml = isXML( elem );

    if ( !xml ) {
        name = name[sym__toLowerCase_]();
    }
    if ( (val = Expr.attrHandle[ name ]) ) {
        return val( elem );
    }
    if ( xml || assertAttributes ) {
        return elem[sym__getAttribute_]( name );
    }
    val = elem[sym__getAttributeNode_]( name );
    return val ?
        typeof elem[ name ] === sym__boolean_ ?
            elem[ name ] ? name : sym__g_null_ :
            val[sym__specified_] ? val[sym__value_] : sym__g_null_ :
        sym__g_null_;
};

Expr = Sizzle[sym__selectors_] = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    // IE6/7 return a modified href
    attrHandle: assertHrefNotNormalized ?
        {} :
        {
            "href": function( elem ) {
                return elem[sym__getAttribute_]( sym__href_, 2 );
            },
            "type": function( elem ) {
                return elem[sym__getAttribute_](sym__type_);
            }
        },

    find: {
        "ID": assertGetIdNotName ?
            function( id, context, xml ) {
                if ( typeof context[sym__getElementById_] !== strundefined && !xml ) {
                    var m = context[sym__getElementById_]( id );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    return m && m[sym__parentNode_] ? [m] : [];
                }
            } :
            function( id, context, xml ) {
                if ( typeof context[sym__getElementById_] !== strundefined && !xml ) {
                    var m = context[sym__getElementById_]( id );

                    return m ?
                        m[sym__id_] === id || typeof m[sym__getAttributeNode_] !== strundefined && m[sym__getAttributeNode_](sym__id_)[sym__value_] === id ?
                            [m] :
                            undefined :
                        [];
                }
            },

        "TAG": assertTagNameNoComments ?
            function( tag, context ) {
                if ( typeof context[sym__getElementsByTagName_] !== strundefined ) {
                    return context[sym__getElementsByTagName_]( tag );
                }
            } :
            function( tag, context ) {
                var results = context[sym__getElementsByTagName_]( tag );

                // Filter out possible comments
                if ( tag === "*" ) {
                    var elem,
                        tmp = [],
                        i = 0;

                    for ( ; (elem = results[i]); i++ ) {
                        if ( elem[sym__nodeType_] === 1 ) {
                            tmp[sym__push_]( elem );
                        }
                    }

                    return tmp;
                }
                return results;
            },

        "NAME": assertUsableName && function( tag, context ) {
            if ( typeof context[sym__getElementsByName_] !== strundefined ) {
                return context[sym__getElementsByName_]( name );
            }
        },

        "CLASS": assertUsableClassName && function( className, context, xml ) {
            if ( typeof context[sym__getElementsByClassName_] !== strundefined && !xml ) {
                return context[sym__getElementsByClassName_]( className );
            }
        }
    },

    relative: {
        ">": { dir: sym__parentNode_, first: sym__g_true_ },
        " ": { dir: sym__parentNode_ },
        "+": { dir: sym__previousSibling_, first: sym__g_true_ },
        "~": { dir: sym__previousSibling_ }
    },

    preFilter: {
        "ATTR": function( match ) {
            match[1] = match[1][sym__replace_]( rbackslash, "" );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[4] || match[5] || "" )[sym__replace_]( rbackslash, "" );

            if ( match[2] === "~=" ) {
                match[3] = " " + match[3] + " ";
            }

            return match[sym__slice_]( 0, 4 );
        },

        "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
                1 type (only|nth|...)
                2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                3 xn-component of xn+y argument ([+-]?\d*n|)
                4 sign of xn-component
                5 x of xn-component
                6 sign of y-component
                7 y of y-component
            */
            match[1] = match[1][sym__toLowerCase_]();

            if ( match[1] === "nth" ) {
                // nth-child requires argument
                if ( !match[2] ) {
                    Sizzle[sym__error_]( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
                match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

            // other types prohibit arguments
            } else if ( match[2] ) {
                Sizzle[sym__error_]( match[0] );
            }

            return match;
        },

        "PSEUDO": function( match ) {
            var unquoted, excess;
            if ( matchExpr[sym__CHILD_][sym__test_]( match[0] ) ) {
                return sym__g_null_;
            }

            if ( match[3] ) {
                match[2] = match[3];
            } else if ( (unquoted = match[4]) ) {
                // Only check arguments that contain a pseudo
                if ( rpseudo[sym__test_](unquoted) &&
                    // Get excess from tokenize (recursively)
                    (excess = tokenize( unquoted, sym__g_true_ )) &&
                    // advance to the next closing parenthesis
                    (excess = unquoted[sym__indexOf_]( ")", unquoted[sym__length_] - excess ) - unquoted[sym__length_]) ) {

                    // excess is a negative index
                    unquoted = unquoted[sym__slice_]( 0, excess );
                    match[0] = match[0][sym__slice_]( 0, excess );
                }
                match[2] = unquoted;
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match[sym__slice_]( 0, 3 );
        }
    },

    filter: {
        "ID": assertGetIdNotName ?
            function( id ) {
                id = id[sym__replace_]( rbackslash, "" );
                return function( elem ) {
                    return elem[sym__getAttribute_](sym__id_) === id;
                };
            } :
            function( id ) {
                id = id[sym__replace_]( rbackslash, "" );
                return function( elem ) {
                    var node = typeof elem[sym__getAttributeNode_] !== strundefined && elem[sym__getAttributeNode_](sym__id_);
                    return node && node[sym__value_] === id;
                };
            },

        "TAG": function( nodeName ) {
            if ( nodeName === "*" ) {
                return function() { return sym__g_true_; };
            }
            nodeName = nodeName[sym__replace_]( rbackslash, "" )[sym__toLowerCase_]();

            return function( elem ) {
                return elem[sym__nodeName_] && elem[sym__nodeName_][sym__toLowerCase_]() === nodeName;
            };
        },

        "CLASS": function( className ) {
            var pattern = classCache[ expando ][ className + " " ];

            return pattern ||
                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                classCache( className, function( elem ) {
                    return pattern[sym__test_]( elem[sym__className_] || (typeof elem[sym__getAttribute_] !== strundefined && elem[sym__getAttribute_]("class")) || "" );
                });
        },

        "ATTR": function( name, operator, check ) {
            return function( elem, context ) {
                var result = Sizzle[sym__attr_]( elem, name );

                if ( result == sym__g_null_ ) {
                    return operator === "!=";
                }
                if ( !operator ) {
                    return sym__g_true_;
                }

                result += "";

                return operator === "=" ? result === check :
                    operator === "!=" ? result !== check :
                    operator === "^=" ? check && result[sym__indexOf_]( check ) === 0 :
                    operator === "*=" ? check && result[sym__indexOf_]( check ) > -1 :
                    operator === "$=" ? check && result[sym__substr_]( result[sym__length_] - check[sym__length_] ) === check :
                    operator === "~=" ? ( " " + result + " " )[sym__indexOf_]( check ) > -1 :
                    operator === "|=" ? result === check || result[sym__substr_]( 0, check[sym__length_] + 1 ) === check + "-" :
                    sym__g_false_;
            };
        },

        "CHILD": function( type, argument, first, last ) {

            if ( type === "nth" ) {
                return function( elem ) {
                    var node, diff,
                        parent = elem[sym__parentNode_];

                    if ( first === 1 && last === 0 ) {
                        return sym__g_true_;
                    }

                    if ( parent ) {
                        diff = 0;
                        for ( node = parent[sym__firstChild_]; node; node = node[sym__nextSibling_] ) {
                            if ( node[sym__nodeType_] === 1 ) {
                                diff++;
                                if ( elem === node ) {
                                    break;
                                }
                            }
                        }
                    }

                    // Incorporate the offset (or cast to NaN), then check against cycle size
                    diff -= last;
                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                };
            }

            return function( elem ) {
                var node = elem;

                switch ( type ) {
                    case "only":
                    case "first":
                        while ( (node = node[sym__previousSibling_]) ) {
                            if ( node[sym__nodeType_] === 1 ) {
                                return sym__g_false_;
                            }
                        }

                        if ( type === sym__first_ ) {
                            return sym__g_true_;
                        }

                        node = elem;

                        /* falls through */
                    case "last":
                        while ( (node = node[sym__nextSibling_]) ) {
                            if ( node[sym__nodeType_] === 1 ) {
                                return sym__g_false_;
                            }
                        }

                        return sym__g_true_;
                }
            };
        },

        "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr[sym__pseudos_][ pseudo ] || Expr[sym__setFilters_][ pseudo[sym__toLowerCase_]() ] ||
                    Sizzle[sym__error_]( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn[sym__length_] > 1 ) {
                args = [ pseudo, pseudo, "", argument ];
                return Expr[sym__setFilters_][sym__hasOwnProperty_]( pseudo[sym__toLowerCase_]() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched[sym__length_];
                        while ( i-- ) {
                            idx = indexOf[sym__call_]( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector[sym__replace_]( rtrim, "$1" ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, sym__g_null_, xml, [] ),
                        i = seed[sym__length_];

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, sym__g_null_, xml, results );
                    return !results.pop();
                };
        }),

        "has": markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem )[sym__length_] > 0;
            };
        }),

        "contains": markFunction(function( text ) {
            return function( elem ) {
                return ( elem[sym__textContent_] || elem.innerText || getText( elem ) )[sym__indexOf_]( text ) > -1;
            };
        }),

        "enabled": function( elem ) {
            return elem[sym__disabled_] === sym__g_false_;
        },

        "disabled": function( elem ) {
            return elem[sym__disabled_] === sym__g_true_;
        },

        "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem[sym__nodeName_][sym__toLowerCase_]();
            return (nodeName === sym__input_ && !!elem[sym__checked_]) || (nodeName === sym__option_ && !!elem[sym__selected_]);
        },

        "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem[sym__parentNode_] ) {
                elem[sym__parentNode_][sym__selectedIndex_];
            }

            return elem[sym__selected_] === sym__g_true_;
        },

        "parent": function( elem ) {
            return !Expr[sym__pseudos_][sym__empty_]( elem );
        },

        "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
            //   not comment, processing instructions, or others
            // Thanks to Diego Perini for the nodeName shortcut
            //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
            var nodeType;
            elem = elem[sym__firstChild_];
            while ( elem ) {
                if ( elem[sym__nodeName_] > "@" || (nodeType = elem[sym__nodeType_]) === 3 || nodeType === 4 ) {
                    return sym__g_false_;
                }
                elem = elem[sym__nextSibling_];
            }
            return sym__g_true_;
        },

        "header": function( elem ) {
            return rheader[sym__test_]( elem[sym__nodeName_] );
        },

        "text": function( elem ) {
            var type, attr;
            // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
            // use getAttribute instead to test this case
            return elem[sym__nodeName_][sym__toLowerCase_]() === sym__input_ &&
                (type = elem[sym__type_]) === sym__text_ &&
                ( (attr = elem[sym__getAttribute_](sym__type_)) == sym__g_null_ || attr[sym__toLowerCase_]() === type );
        },

        // Input types
        "radio": createInputPseudo(sym__radio_),
        "checkbox": createInputPseudo(sym__checkbox_),
        "file": createInputPseudo("file"),
        "password": createInputPseudo(sym__password_),
        "image": createInputPseudo("image"),

        "submit": createButtonPseudo(sym__submit_),
        "reset": createButtonPseudo("reset"),

        "button": function( elem ) {
            var name = elem[sym__nodeName_][sym__toLowerCase_]();
            return name === sym__input_ && elem[sym__type_] === sym__button_ || name === sym__button_;
        },

        "input": function( elem ) {
            return rinputs[sym__test_]( elem[sym__nodeName_] );
        },

        "focus": function( elem ) {
            var doc = elem[sym__ownerDocument_];
            return elem === doc[sym__activeElement_] && (!doc.hasFocus || doc.hasFocus()) && !!(elem[sym__type_] || elem[sym__href_] || ~elem.tabIndex);
        },

        "active": function( elem ) {
            return elem === elem[sym__ownerDocument_][sym__activeElement_];
        },

        // Positional types
        "first": createPositionalPseudo(function() {
            return [ 0 ];
        }),

        "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
        }),

        "even": createPositionalPseudo(function( matchIndexes, length ) {
            for ( var i = 0; i < length; i += 2 ) {
                matchIndexes[sym__push_]( i );
            }
            return matchIndexes;
        }),

        "odd": createPositionalPseudo(function( matchIndexes, length ) {
            for ( var i = 1; i < length; i += 2 ) {
                matchIndexes[sym__push_]( i );
            }
            return matchIndexes;
        }),

        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
                matchIndexes[sym__push_]( i );
            }
            return matchIndexes;
        }),

        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
                matchIndexes[sym__push_]( i );
            }
            return matchIndexes;
        })
    }
};

function siblingCheck( a, b, ret ) {
    if ( a === b ) {
        return ret;
    }

    var cur = a[sym__nextSibling_];

    while ( cur ) {
        if ( cur === b ) {
            return -1;
        }

        cur = cur[sym__nextSibling_];
    }

    return 1;
}

sortOrder = docElem[sym__compareDocumentPosition_] ?
    function( a, b ) {
        if ( a === b ) {
            hasDuplicate = sym__g_true_;
            return 0;
        }

        return ( !a[sym__compareDocumentPosition_] || !b[sym__compareDocumentPosition_] ?
            a[sym__compareDocumentPosition_] :
            a[sym__compareDocumentPosition_](b) & 4
        ) ? -1 : 1;
    } :
    function( a, b ) {
        // The nodes are identical, we can exit early
        if ( a === b ) {
            hasDuplicate = sym__g_true_;
            return 0;

        // Fallback to using sourceIndex (in IE) if it's available on both nodes
        } else if ( a[sym__sourceIndex_] && b[sym__sourceIndex_] ) {
            return a[sym__sourceIndex_] - b[sym__sourceIndex_];
        }

        var al, bl,
            ap = [],
            bp = [],
            aup = a[sym__parentNode_],
            bup = b[sym__parentNode_],
            cur = aup;

        // If the nodes are siblings (or identical) we can do a quick check
        if ( aup === bup ) {
            return siblingCheck( a, b );

        // If no parents were found then the nodes are disconnected
        } else if ( !aup ) {
            return -1;

        } else if ( !bup ) {
            return 1;
        }

        // Otherwise they're somewhere else in the tree so we need
        // to build up a full list of the parentNodes for comparison
        while ( cur ) {
            ap[sym__unshift_]( cur );
            cur = cur[sym__parentNode_];
        }

        cur = bup;

        while ( cur ) {
            bp[sym__unshift_]( cur );
            cur = cur[sym__parentNode_];
        }

        al = ap[sym__length_];
        bl = bp[sym__length_];

        // Start walking down the tree looking for a discrepancy
        for ( var i = 0; i < al && i < bl; i++ ) {
            if ( ap[i] !== bp[i] ) {
                return siblingCheck( ap[i], bp[i] );
            }
        }

        // We ended someplace up the tree so do a sibling check
        return i === al ?
            siblingCheck( a, bp[i], -1 ) :
            siblingCheck( ap[i], b, 1 );
    };

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0][sym__sort_]( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle[sym__uniqueSort_] = function( results ) {
    var elem,
        duplicates = [],
        i = 1,
        j = 0;

    hasDuplicate = baseHasDuplicate;
    results[sym__sort_]( sortOrder );

    if ( hasDuplicate ) {
        for ( ; (elem = results[i]); i++ ) {
            if ( elem === results[ i - 1 ] ) {
                j = duplicates[sym__push_]( i );
            }
        }
        while ( j-- ) {
            results[sym__splice_]( duplicates[ j ], 1 );
        }
    }

    return results;
};

Sizzle[sym__error_] = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ expando ][ selector + " " ];

    if ( cached ) {
        return parseOnly ? 0 : cached[sym__slice_]( 0 );
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma[sym__exec_]( soFar )) ) {
            if ( match ) {
                // Don't consume trailing commas as valid
                soFar = soFar[sym__slice_]( match[0][sym__length_] ) || soFar;
            }
            groups[sym__push_]( tokens = [] );
        }

        matched = sym__g_false_;

        // Combinators
        if ( (match = rcombinators[sym__exec_]( soFar )) ) {
            tokens[sym__push_]( matched = new Token( match[sym__shift_]() ) );
            soFar = soFar[sym__slice_]( matched[sym__length_] );

            // Cast descendant combinators to space
            matched[sym__type_] = match[0][sym__replace_]( rtrim, " " );
        }

        // Filters
        for ( type in Expr[sym__filter_] ) {
            if ( (match = matchExpr[ type ][sym__exec_]( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {

                tokens[sym__push_]( matched = new Token( match[sym__shift_]() ) );
                soFar = soFar[sym__slice_]( matched[sym__length_] );
                matched[sym__type_] = type;
                matched[sym__matches_] = match;
            }
        }

        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
        soFar[sym__length_] :
        soFar ?
            Sizzle[sym__error_]( selector ) :
            // Cache the tokens
            tokenCache( selector, groups )[sym__slice_]( 0 );
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator[sym__dir_],
        checkNonElements = base && combinator[sym__dir_] === sym__parentNode_,
        doneName = done++;

    return combinator[sym__first_] ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( checkNonElements || elem[sym__nodeType_] === 1  ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if ( !xml ) {
                var cache,
                    dirkey = dirruns + " " + doneName + " ",
                    cachedkey = dirkey + cachedruns;
                while ( (elem = elem[ dir ]) ) {
                    if ( checkNonElements || elem[sym__nodeType_] === 1 ) {
                        if ( (cache = elem[ expando ]) === cachedkey ) {
                            return elem[sym__sizset_];
                        } else if ( typeof cache === sym__string_ && cache[sym__indexOf_](dirkey) === 0 ) {
                            if ( elem[sym__sizset_] ) {
                                return elem;
                            }
                        } else {
                            elem[ expando ] = cachedkey;
                            if ( matcher( elem, context, xml ) ) {
                                elem[sym__sizset_] = sym__g_true_;
                                return elem;
                            }
                            elem[sym__sizset_] = sym__g_false_;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( checkNonElements || elem[sym__nodeType_] === 1 ) {
                        if ( matcher( elem, context, xml ) ) {
                            return elem;
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers[sym__length_] > 1 ?
        function( elem, context, xml ) {
            var i = matchers[sym__length_];
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return sym__g_false_;
                }
            }
            return sym__g_true_;
        } :
        matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched[sym__length_],
        mapped = map != sym__g_null_;

    for ( ; i < len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched[sym__push_]( elem );
                if ( mapped ) {
                    map[sym__push_]( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results[sym__length_],

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context[sym__nodeType_] ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp[sym__length_];
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut[sym__length_];
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp[sym__push_]( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( sym__g_null_, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut[sym__length_];
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf[sym__call_]( seed, elem ) : preMap[i]) > -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut[sym__splice_]( preexisting, matcherOut[sym__length_] ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( sym__g_null_, results, matcherOut, xml );
            } else {
                push[sym__apply_]( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens[sym__length_],
        leadingRelative = Expr[sym__relative_][ tokens[0][sym__type_] ],
        implicitRelative = leadingRelative || Expr[sym__relative_][" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, sym__g_true_ ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf[sym__call_]( checkContext, elem ) > -1;
        }, implicitRelative, sym__g_true_ ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context)[sym__nodeType_] ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i < len; i++ ) {
        if ( (matcher = Expr[sym__relative_][ tokens[i][sym__type_] ]) ) {
            matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
        } else {
            matcher = Expr[sym__filter_][ tokens[i][sym__type_] ][sym__apply_]( sym__g_null_, tokens[i][sym__matches_] );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j < len; j++ ) {
                    if ( Expr[sym__relative_][ tokens[j][sym__type_] ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && tokens[sym__slice_]( 0, i - 1 )[sym__join_]("")[sym__replace_]( rtrim, "$1" ),
                    matcher,
                    i < j && matcherFromTokens( tokens[sym__slice_]( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens[sym__slice_]( j )) ),
                    j < len && tokens[sym__join_]("")
                );
            }
            matchers[sym__push_]( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers[sym__length_] > 0,
        byElement = elementMatchers[sym__length_] > 0,
        superMatcher = function( seed, context, xml, results, expandContext ) {
            var elem, j, matcher,
                setMatched = [],
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                outermost = expandContext != sym__g_null_,
                contextBackup = outermostContext,
                // We must always have either seed elements or context
                elems = seed || byElement && Expr[sym__find_]["TAG"]( "*", expandContext && context[sym__parentNode_] || context ),
                // Nested matchers should use non-integer dirruns
                dirrunsUnique = (dirruns += contextBackup == sym__g_null_ ? 1 : Math.E);

            if ( outermost ) {
                outermostContext = context !== document && context;
                cachedruns = superMatcher.el;
            }

            // Add elements passing elementMatchers directly to results
            for ( ; (elem = elems[i]) != sym__g_null_; i++ ) {
                if ( byElement && elem ) {
                    for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
                        if ( matcher( elem, context, xml ) ) {
                            results[sym__push_]( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                        cachedruns = ++superMatcher.el;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher && elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched[sym__push_]( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet && i !== matchedCount ) {
                for ( j = 0; (matcher = setMatchers[j]); j++ ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount > 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop[sym__call_]( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push[sym__apply_]( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost && !seed && setMatched[sym__length_] > 0 &&
                    ( matchedCount + setMatchers[sym__length_] ) > 1 ) {

                    Sizzle[sym__uniqueSort_]( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    superMatcher.el = 0;
    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ expando ][ selector + " " ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !group ) {
            group = tokenize( selector );
        }
        i = group[sym__length_];
        while ( i-- ) {
            cached = matcherFromTokens( group[i] );
            if ( cached[ expando ] ) {
                setMatchers[sym__push_]( cached );
            } else {
                elementMatchers[sym__push_]( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    }
    return cached;
};

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts[sym__length_];
    for ( ; i < len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

function select( selector, context, results, seed, xml ) {
    var i, tokens, token, type, find,
        match = tokenize( selector ),
        j = match[sym__length_];

    if ( !seed ) {
        // Try to minimize operations if there is only one group
        if ( match[sym__length_] === 1 ) {

            // Take a shortcut and set the context if the root selector is an ID
            tokens = match[0] = match[0][sym__slice_]( 0 );
            if ( tokens[sym__length_] > 2 && (token = tokens[0])[sym__type_] === "ID" &&
                    context[sym__nodeType_] === 9 && !xml &&
                    Expr[sym__relative_][ tokens[1][sym__type_] ] ) {

                context = Expr[sym__find_]["ID"]( token[sym__matches_][0][sym__replace_]( rbackslash, "" ), context, xml )[0];
                if ( !context ) {
                    return results;
                }

                selector = selector[sym__slice_]( tokens[sym__shift_]()[sym__length_] );
            }

            // Fetch a seed set for right-to-left matching
            for ( i = matchExpr["POS"][sym__test_]( selector ) ? -1 : tokens[sym__length_] - 1; i >= 0; i-- ) {
                token = tokens[i];

                // Abort if we hit a combinator
                if ( Expr[sym__relative_][ (type = token[sym__type_]) ] ) {
                    break;
                }
                if ( (find = Expr[sym__find_][ type ]) ) {
                    // Search, expanding context for leading sibling combinators
                    if ( (seed = find(
                        token[sym__matches_][0][sym__replace_]( rbackslash, "" ),
                        rsibling[sym__test_]( tokens[0][sym__type_] ) && context[sym__parentNode_] || context,
                        xml
                    )) ) {

                        // If seed is empty or no tokens remain, we can return early
                        tokens[sym__splice_]( i, 1 );
                        selector = seed[sym__length_] && tokens[sym__join_]("");
                        if ( !selector ) {
                            push[sym__apply_]( results, slice[sym__call_]( seed, 0 ) );
                            return results;
                        }

                        break;
                    }
                }
            }
        }
    }

    // Compile and execute a filtering function
    // Provide `match` to avoid retokenization if we modified the selector above
    compile( selector, match )(
        seed,
        context,
        xml,
        results,
        rsibling[sym__test_]( selector )
    );
    return results;
}

if ( document[sym__querySelectorAll_] ) {
    (function() {
        var disconnectedMatch,
            oldSelect = select,
            rescape = /'|\\/g,
            rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

            // qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
            // A support test would require too much code (would include document ready)
            rbuggyQSA = [ ":focus" ],

            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            // A support test would require too much code (would include document ready)
            // just skip matchesSelector for :active
            rbuggyMatches = [ ":active" ],
            matches = docElem[sym__matchesSelector_] ||
                docElem.mozMatchesSelector ||
                docElem.webkitMatchesSelector ||
                docElem.oMatchesSelector ||
                docElem.msMatchesSelector;

        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explictly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div[sym__innerHTML_] = "<select><option selected=''></option></select>";

            // IE8 - Some boolean attributes are not treated correctly
            if ( !div[sym__querySelectorAll_]("[selected]")[sym__length_] ) {
                rbuggyQSA[sym__push_]( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here (do not put tests after this one)
            if ( !div[sym__querySelectorAll_](":checked")[sym__length_] ) {
                rbuggyQSA[sym__push_](":checked");
            }
        });

        assert(function( div ) {

            // Opera 10-12/IE9 - ^= $= *= and empty values
            // Should not select anything
            div[sym__innerHTML_] = "<p test=''></p>";
            if ( div[sym__querySelectorAll_]("[test^='']")[sym__length_] ) {
                rbuggyQSA[sym__push_]( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here (do not put tests after this one)
            div[sym__innerHTML_] = "<input type='hidden'/>";
            if ( !div[sym__querySelectorAll_](":enabled")[sym__length_] ) {
                rbuggyQSA[sym__push_](":enabled", ":disabled");
            }
        });

        // rbuggyQSA always contains :focus, so no need for a length check
        rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA[sym__join_]("|") );

        select = function( selector, context, results, seed, xml ) {
            // Only use querySelectorAll when not filtering,
            // when this is not xml,
            // and when no QSA bugs apply
            if ( !seed && !xml && !rbuggyQSA[sym__test_]( selector ) ) {
                var groups, i,
                    old = sym__g_true_,
                    nid = expando,
                    newContext = context,
                    newSelector = context[sym__nodeType_] === 9 && selector;

                // qSA works strangely on Element-rooted queries
                // We can work around this by specifying an extra ID on the root
                // and working up from there (Thanks to Andrew Dupont for the technique)
                // IE 8 doesn't work on object elements
                if ( context[sym__nodeType_] === 1 && context[sym__nodeName_][sym__toLowerCase_]() !== sym__object_ ) {
                    groups = tokenize( selector );

                    if ( (old = context[sym__getAttribute_](sym__id_)) ) {
                        nid = old[sym__replace_]( rescape, "\\$&" );
                    } else {
                        context[sym__setAttribute_]( sym__id_, nid );
                    }
                    nid = "[id='" + nid + "'] ";

                    i = groups[sym__length_];
                    while ( i-- ) {
                        groups[i] = nid + groups[i][sym__join_]("");
                    }
                    newContext = rsibling[sym__test_]( selector ) && context[sym__parentNode_] || context;
                    newSelector = groups[sym__join_](",");
                }

                if ( newSelector ) {
                    try {
                        push[sym__apply_]( results, slice[sym__call_]( newContext[sym__querySelectorAll_](
                            newSelector
                        ), 0 ) );
                        return results;
                    } catch(qsaError) {
                    } finally {
                        if ( !old ) {
                            context[sym__removeAttribute_](sym__id_);
                        }
                    }
                }
            }

            return oldSelect( selector, context, results, seed, xml );
        };

        if ( matches ) {
            assert(function( div ) {
                // Check to see if it's possible to do matchesSelector
                // on a disconnected node (IE 9)
                disconnectedMatch = matches[sym__call_]( div, sym__div_ );

                // This should fail with an exception
                // Gecko does not error, returns false instead
                try {
                    matches[sym__call_]( div, "[test!='']:sizzle" );
                    rbuggyMatches[sym__push_]( "!=", pseudos );
                } catch ( e ) {}
            });

            // rbuggyMatches always contains :active and :focus, so no need for a length check
            rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches[sym__join_]("|") );

            Sizzle[sym__matchesSelector_] = function( elem, expr ) {
                // Make sure that attribute selectors are quoted
                expr = expr[sym__replace_]( rattributeQuotes, "='$1']" );

                // rbuggyMatches always contains :active, so no need for an existence check
                if ( !isXML( elem ) && !rbuggyMatches[sym__test_]( expr ) && !rbuggyQSA[sym__test_]( expr ) ) {
                    try {
                        var ret = matches[sym__call_]( elem, expr );

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if ( ret || disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9
                                elem[sym__document_] && elem[sym__document_][sym__nodeType_] !== 11 ) {
                            return ret;
                        }
                    } catch(e) {}
                }

                return Sizzle( expr, sym__g_null_, sym__g_null_, [ elem ] )[sym__length_] > 0;
            };
        }
    })();
}

// Deprecated
Expr[sym__pseudos_]["nth"] = Expr[sym__pseudos_]["eq"];

// Back-compat
function setFilters() {}
Expr[sym__filters_] = setFilters[sym__prototype_] = Expr[sym__pseudos_];
Expr[sym__setFilters_] = new setFilters();

// Override sizzle attribute retrieval
Sizzle[sym__attr_] = jQuery[sym__attr_];
jQuery[sym__find_] = Sizzle;
jQuery[sym__expr_] = Sizzle[sym__selectors_];
jQuery[sym__expr_][":"] = jQuery[sym__expr_][sym__pseudos_];
jQuery[sym__unique_] = Sizzle[sym__uniqueSort_];
jQuery[sym__text_] = Sizzle.getText;
jQuery[sym__isXMLDoc_] = Sizzle.isXML;
jQuery[sym__contains_] = Sizzle[sym__contains_];


})( sym__g_window_ );
var runtil = /Until$/,
    rparentsprev = /^(?:parents|prev(?:Until|All))/,
    isSimple = /^.[^:#\[\.,]*$/,
    rneedsContext = jQuery[sym__expr_].match[sym__needsContext_],
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: sym__g_true_,
        contents: sym__g_true_,
        next: sym__g_true_,
        prev: sym__g_true_
    };

jQuery[sym__fn_][sym__extend_]({
    find: function( selector ) {
        var i, l, length, n, r, ret,
            self = this;

        if ( typeof selector !== sym__string_ ) {
            return jQuery( selector )[sym__filter_](function() {
                for ( i = 0, l = self[sym__length_]; i < l; i++ ) {
                    if ( jQuery[sym__contains_]( self[ i ], this ) ) {
                        return sym__g_true_;
                    }
                }
            });
        }

        ret = this[sym__pushStack_]( "", sym__find_, selector );

        for ( i = 0, l = this[sym__length_]; i < l; i++ ) {
            length = ret[sym__length_];
            jQuery[sym__find_]( selector, this[i], ret );

            if ( i > 0 ) {
                // Make sure that the results are unique
                for ( n = length; n < ret[sym__length_]; n++ ) {
                    for ( r = 0; r < length; r++ ) {
                        if ( ret[r] === ret[n] ) {
                            ret[sym__splice_](n--, 1);
                            break;
                        }
                    }
                }
            }
        }

        return ret;
    },

    has: function( target ) {
        var i,
            targets = jQuery( target, this ),
            len = targets[sym__length_];

        return this[sym__filter_](function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery[sym__contains_]( this, targets[i] ) ) {
                    return sym__g_true_;
                }
            }
        });
    },

    not: function( selector ) {
        return this[sym__pushStack_]( winnow(this, selector, sym__g_false_), "not", selector);
    },

    filter: function( selector ) {
        return this[sym__pushStack_]( winnow(this, selector, sym__g_true_), sym__filter_, selector );
    },

    is: function( selector ) {
        return !!selector && (
            typeof selector === sym__string_ ?
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                rneedsContext[sym__test_]( selector ) ?
                    jQuery( selector, this[sym__context_] )[sym__index_]( this[0] ) >= 0 :
                    jQuery[sym__filter_]( selector, this )[sym__length_] > 0 :
                this[sym__filter_]( selector )[sym__length_] > 0 );
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this[sym__length_],
            ret = [],
            pos = rneedsContext[sym__test_]( selectors ) || typeof selectors !== sym__string_ ?
                jQuery( selectors, context || this[sym__context_] ) :
                0;

        for ( ; i < l; i++ ) {
            cur = this[i];

            while ( cur && cur[sym__ownerDocument_] && cur !== context && cur[sym__nodeType_] !== 11 ) {
                if ( pos ? pos[sym__index_](cur) > -1 : jQuery[sym__find_][sym__matchesSelector_](cur, selectors) ) {
                    ret[sym__push_]( cur );
                    break;
                }
                cur = cur[sym__parentNode_];
            }
        }

        ret = ret[sym__length_] > 1 ? jQuery[sym__unique_]( ret ) : ret;

        return this[sym__pushStack_]( ret, "closest", selectors );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[0] && this[0][sym__parentNode_] ) ? this.prevAll()[sym__length_] : -1;
        }

        // index in selector
        if ( typeof elem === sym__string_ ) {
            return jQuery[sym__inArray_]( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery[sym__inArray_](
            // If it receives a jQuery object, the first element is used
            elem[sym__jquery_] ? elem[0] : elem, this );
    },

    add: function( selector, context ) {
        var set = typeof selector === sym__string_ ?
                jQuery( selector, context ) :
                jQuery[sym__makeArray_]( selector && selector[sym__nodeType_] ? [ selector ] : selector ),
            all = jQuery[sym__merge_]( this[sym__get_](), set );

        return this[sym__pushStack_]( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
            all :
            jQuery[sym__unique_]( all ) );
    },

    addBack: function( selector ) {
        return this[sym__add_]( selector == sym__g_null_ ?
            this[sym__prevObject_] : this[sym__prevObject_][sym__filter_](selector)
        );
    }
});

jQuery[sym__fn_].andSelf = jQuery[sym__fn_].addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
    return !node || !node[sym__parentNode_] || node[sym__parentNode_][sym__nodeType_] === 11;
}

function sibling( cur, dir ) {
    do {
        cur = cur[ dir ];
    } while ( cur && cur[sym__nodeType_] !== 1 );

    return cur;
}

jQuery[sym__each_]({
    parent: function( elem ) {
        var parent = elem[sym__parentNode_];
        return parent && parent[sym__nodeType_] !== 11 ? parent : sym__g_null_;
    },
    parents: function( elem ) {
        return jQuery[sym__dir_]( elem, sym__parentNode_ );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery[sym__dir_]( elem, sym__parentNode_, until );
    },
    next: function( elem ) {
        return sibling( elem, sym__nextSibling_ );
    },
    prev: function( elem ) {
        return sibling( elem, sym__previousSibling_ );
    },
    nextAll: function( elem ) {
        return jQuery[sym__dir_]( elem, sym__nextSibling_ );
    },
    prevAll: function( elem ) {
        return jQuery[sym__dir_]( elem, sym__previousSibling_ );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery[sym__dir_]( elem, sym__nextSibling_, until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery[sym__dir_]( elem, sym__previousSibling_, until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem[sym__parentNode_] || {} )[sym__firstChild_], elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem[sym__firstChild_] );
    },
    contents: function( elem ) {
        return jQuery[sym__nodeName_]( elem, "iframe" ) ?
            elem[sym__contentDocument_] || elem[sym__contentWindow_][sym__document_] :
            jQuery[sym__merge_]( [], elem[sym__childNodes_] );
    }
}, function( name, fn ) {
    jQuery[sym__fn_][ name ] = function( until, selector ) {
        var ret = jQuery[sym__map_]( this, fn, until );

        if ( !runtil[sym__test_]( name ) ) {
            selector = until;
        }

        if ( selector && typeof selector === sym__string_ ) {
            ret = jQuery[sym__filter_]( selector, ret );
        }

        ret = this[sym__length_] > 1 && !guaranteedUnique[ name ] ? jQuery[sym__unique_]( ret ) : ret;

        if ( this[sym__length_] > 1 && rparentsprev[sym__test_]( name ) ) {
            ret = ret.reverse();
        }

        return this[sym__pushStack_]( ret, name, core_slice[sym__call_]( arguments )[sym__join_](",") );
    };
});

jQuery[sym__extend_]({
    filter: function( expr, elems, not ) {
        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        return elems[sym__length_] === 1 ?
            jQuery[sym__find_][sym__matchesSelector_](elems[0], expr) ? [ elems[0] ] : [] :
            jQuery[sym__find_][sym__matches_](expr, elems);
    },

    dir: function( elem, dir, until ) {
        var matched = [],
            cur = elem[ dir ];

        while ( cur && cur[sym__nodeType_] !== 9 && (until === undefined || cur[sym__nodeType_] !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur[sym__nodeType_] === 1 ) {
                matched[sym__push_]( cur );
            }
            cur = cur[dir];
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n[sym__nextSibling_] ) {
            if ( n[sym__nodeType_] === 1 && n !== elem ) {
                r[sym__push_]( n );
            }
        }

        return r;
    }
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

    // Can't pass null or undefined to indexOf in Firefox 4
    // Set to 0 to skip string check
    qualifier = qualifier || 0;

    if ( jQuery[sym__isFunction_]( qualifier ) ) {
        return jQuery[sym__grep_](elements, function( elem, i ) {
            var retVal = !!qualifier[sym__call_]( elem, i, elem );
            return retVal === keep;
        });

    } else if ( qualifier[sym__nodeType_] ) {
        return jQuery[sym__grep_](elements, function( elem, i ) {
            return ( elem === qualifier ) === keep;
        });

    } else if ( typeof qualifier === sym__string_ ) {
        var filtered = jQuery[sym__grep_](elements, function( elem ) {
            return elem[sym__nodeType_] === 1;
        });

        if ( isSimple[sym__test_]( qualifier ) ) {
            return jQuery[sym__filter_](qualifier, filtered, !keep);
        } else {
            qualifier = jQuery[sym__filter_]( qualifier, filtered );
        }
    }

    return jQuery[sym__grep_](elements, function( elem, i ) {
        return ( jQuery[sym__inArray_]( elem, qualifier ) >= 0 ) === keep;
    });
}
function createSafeFragment( document ) {
    var list = nodeNames[sym__split_]( "|" ),
    safeFrag = document[sym__createDocumentFragment_]();

    if ( safeFrag[sym__createElement_] ) {
        while ( list[sym__length_] ) {
            safeFrag[sym__createElement_](
                list.pop()
            );
        }
    }
    return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rleadingWhitespace = /^\s+/,
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rtbody = /<tbody/i,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    rnocache = /<(?:script|object|embed|option|style)/i,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rcheckableType = /^(?:checkbox|radio)$/,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /\/(java|ecma)script/i,
    rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        area: [ 1, "<map>", "</map>" ],
        _default: [ 0, "", "" ]
    },
    safeFragment = createSafeFragment( document ),
    fragmentDiv = safeFragment[sym__appendChild_]( document[sym__createElement_](sym__div_) );

wrapMap.optgroup = wrapMap[sym__option_];
wrapMap[sym__tbody_] = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery[sym__support_][sym__htmlSerialize_] ) {
    wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery[sym__fn_][sym__extend_]({
    text: function( value ) {
        return jQuery[sym__access_]( this, function( value ) {
            return value === undefined ?
                jQuery[sym__text_]( this ) :
                this[sym__empty_]()[sym__append_]( ( this[0] && this[0][sym__ownerDocument_] || document )[sym__createTextNode_]( value ) );
        }, sym__g_null_, value, arguments[sym__length_] );
    },

    wrapAll: function( html ) {
        if ( jQuery[sym__isFunction_]( html ) ) {
            return this[sym__each_](function(i) {
                jQuery(this)[sym__wrapAll_]( html[sym__call_](this, i) );
            });
        }

        if ( this[0] ) {
            // The elements to wrap the target around
            var wrap = jQuery( html, this[0][sym__ownerDocument_] ).eq(0)[sym__clone_](sym__g_true_);

            if ( this[0][sym__parentNode_] ) {
                wrap[sym__insertBefore_]( this[0] );
            }

            wrap[sym__map_](function() {
                var elem = this;

                while ( elem[sym__firstChild_] && elem[sym__firstChild_][sym__nodeType_] === 1 ) {
                    elem = elem[sym__firstChild_];
                }

                return elem;
            })[sym__append_]( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery[sym__isFunction_]( html ) ) {
            return this[sym__each_](function(i) {
                jQuery(this).wrapInner( html[sym__call_](this, i) );
            });
        }

        return this[sym__each_](function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents[sym__length_] ) {
                contents[sym__wrapAll_]( html );

            } else {
                self[sym__append_]( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery[sym__isFunction_]( html );

        return this[sym__each_](function(i) {
            jQuery( this )[sym__wrapAll_]( isFunction ? html[sym__call_](this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent()[sym__each_](function() {
            if ( !jQuery[sym__nodeName_]( this, sym__body_ ) ) {
                jQuery( this )[sym__replaceWith_]( this[sym__childNodes_] );
            }
        }).end();
    },

    append: function() {
        return this[sym__domManip_](arguments, sym__g_true_, function( elem ) {
            if ( this[sym__nodeType_] === 1 || this[sym__nodeType_] === 11 ) {
                this[sym__appendChild_]( elem );
            }
        });
    },

    prepend: function() {
        return this[sym__domManip_](arguments, sym__g_true_, function( elem ) {
            if ( this[sym__nodeType_] === 1 || this[sym__nodeType_] === 11 ) {
                this[sym__insertBefore_]( elem, this[sym__firstChild_] );
            }
        });
    },

    before: function() {
        if ( !isDisconnected( this[0] ) ) {
            return this[sym__domManip_](arguments, sym__g_false_, function( elem ) {
                this[sym__parentNode_][sym__insertBefore_]( elem, this );
            });
        }

        if ( arguments[sym__length_] ) {
            var set = jQuery[sym__clean_]( arguments );
            return this[sym__pushStack_]( jQuery[sym__merge_]( set, this ), sym__before_, this[sym__selector_] );
        }
    },

    after: function() {
        if ( !isDisconnected( this[0] ) ) {
            return this[sym__domManip_](arguments, sym__g_false_, function( elem ) {
                this[sym__parentNode_][sym__insertBefore_]( elem, this[sym__nextSibling_] );
            });
        }

        if ( arguments[sym__length_] ) {
            var set = jQuery[sym__clean_]( arguments );
            return this[sym__pushStack_]( jQuery[sym__merge_]( this, set ), "after", this[sym__selector_] );
        }
    },

    // keepData is for internal use only--do not document
    remove: function( selector, keepData ) {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != sym__g_null_; i++ ) {
            if ( !selector || jQuery[sym__filter_]( selector, [ elem ] )[sym__length_] ) {
                if ( !keepData && elem[sym__nodeType_] === 1 ) {
                    jQuery[sym__cleanData_]( elem[sym__getElementsByTagName_]("*") );
                    jQuery[sym__cleanData_]( [ elem ] );
                }

                if ( elem[sym__parentNode_] ) {
                    elem[sym__parentNode_][sym__removeChild_]( elem );
                }
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != sym__g_null_; i++ ) {
            // Remove element nodes and prevent memory leaks
            if ( elem[sym__nodeType_] === 1 ) {
                jQuery[sym__cleanData_]( elem[sym__getElementsByTagName_]("*") );
            }

            // Remove any remaining nodes
            while ( elem[sym__firstChild_] ) {
                elem[sym__removeChild_]( elem[sym__firstChild_] );
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == sym__g_null_ ? sym__g_false_ : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == sym__g_null_ ? dataAndEvents : deepDataAndEvents;

        return this[sym__map_]( function () {
            return jQuery[sym__clone_]( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return jQuery[sym__access_]( this, function( value ) {
            var elem = this[0] || {},
                i = 0,
                l = this[sym__length_];

            if ( value === undefined ) {
                return elem[sym__nodeType_] === 1 ?
                    elem[sym__innerHTML_][sym__replace_]( rinlinejQuery, "" ) :
                    undefined;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === sym__string_ && !rnoInnerhtml[sym__test_]( value ) &&
                ( jQuery[sym__support_][sym__htmlSerialize_] || !rnoshimcache[sym__test_]( value )  ) &&
                ( jQuery[sym__support_][sym__leadingWhitespace_] || !rleadingWhitespace[sym__test_]( value ) ) &&
                !wrapMap[ ( rtagName[sym__exec_]( value ) || ["", ""] )[1][sym__toLowerCase_]() ] ) {

                value = value[sym__replace_]( rxhtmlTag, "<$1></$2>" );

                try {
                    for (; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        elem = this[i] || {};
                        if ( elem[sym__nodeType_] === 1 ) {
                            jQuery[sym__cleanData_]( elem[sym__getElementsByTagName_]( "*" ) );
                            elem[sym__innerHTML_] = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {}
            }

            if ( elem ) {
                this[sym__empty_]()[sym__append_]( value );
            }
        }, sym__g_null_, value, arguments[sym__length_] );
    },

    replaceWith: function( value ) {
        if ( !isDisconnected( this[0] ) ) {
            // Make sure that the elements are removed from the DOM before they are inserted
            // this can help fix replacing a parent with child elements
            if ( jQuery[sym__isFunction_]( value ) ) {
                return this[sym__each_](function(i) {
                    var self = jQuery(this), old = self[sym__html_]();
                    self[sym__replaceWith_]( value[sym__call_]( this, i, old ) );
                });
            }

            if ( typeof value !== sym__string_ ) {
                value = jQuery( value ).detach();
            }

            return this[sym__each_](function() {
                var next = this[sym__nextSibling_],
                    parent = this[sym__parentNode_];

                jQuery( this )[sym__remove_]();

                if ( next ) {
                    jQuery(next)[sym__before_]( value );
                } else {
                    jQuery(parent)[sym__append_]( value );
                }
            });
        }

        return this[sym__length_] ?
            this[sym__pushStack_]( jQuery(jQuery[sym__isFunction_](value) ? value() : value), sym__replaceWith_, value ) :
            this;
    },

    detach: function( selector ) {
        return this[sym__remove_]( selector, sym__g_true_ );
    },

    domManip: function( args, table, callback ) {

        // Flatten any nested arrays
        args = [][sym__concat_][sym__apply_]( [], args );

        var results, first, fragment, iNoClone,
            i = 0,
            value = args[0],
            scripts = [],
            l = this[sym__length_];

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( !jQuery[sym__support_][sym__checkClone_] && l > 1 && typeof value === sym__string_ && rchecked[sym__test_]( value ) ) {
            return this[sym__each_](function() {
                jQuery(this)[sym__domManip_]( args, table, callback );
            });
        }

        if ( jQuery[sym__isFunction_](value) ) {
            return this[sym__each_](function(i) {
                var self = jQuery(this);
                args[0] = value[sym__call_]( this, i, table ? self[sym__html_]() : undefined );
                self[sym__domManip_]( args, table, callback );
            });
        }

        if ( this[0] ) {
            results = jQuery[sym__buildFragment_]( args, this, scripts );
            fragment = results[sym__fragment_];
            first = fragment[sym__firstChild_];

            if ( fragment[sym__childNodes_][sym__length_] === 1 ) {
                fragment = first;
            }

            if ( first ) {
                table = table && jQuery[sym__nodeName_]( first, "tr" );

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                // Fragments from the fragment cache must always be cloned and never used in place.
                for ( iNoClone = results[sym__cacheable_] || l - 1; i < l; i++ ) {
                    callback[sym__call_](
                        table && jQuery[sym__nodeName_]( this[i], "table" ) ?
                            findOrAppend( this[i], sym__tbody_ ) :
                            this[i],
                        i === iNoClone ?
                            fragment :
                            jQuery[sym__clone_]( fragment, sym__g_true_, sym__g_true_ )
                    );
                }
            }

            // Fix #11809: Avoid leaking memory
            fragment = first = sym__g_null_;

            if ( scripts[sym__length_] ) {
                jQuery[sym__each_]( scripts, function( i, elem ) {
                    if ( elem.src ) {
                        if ( jQuery[sym__ajax_] ) {
                            jQuery[sym__ajax_]({
                                url: elem.src,
                                type: "GET",
                                dataType: sym__script_,
                                async: sym__g_false_,
                                global: sym__g_false_,
                                "throws": sym__g_true_
                            });
                        } else {
                            jQuery[sym__error_]("no ajax");
                        }
                    } else {
                        jQuery[sym__globalEval_]( ( elem[sym__text_] || elem[sym__textContent_] || elem[sym__innerHTML_] || "" )[sym__replace_]( rcleanScript, "" ) );
                    }

                    if ( elem[sym__parentNode_] ) {
                        elem[sym__parentNode_][sym__removeChild_]( elem );
                    }
                });
            }
        }

        return this;
    }
});

function findOrAppend( elem, tag ) {
    return elem[sym__getElementsByTagName_]( tag )[0] || elem[sym__appendChild_]( elem[sym__ownerDocument_][sym__createElement_]( tag ) );
}

function cloneCopyEvent( src, dest ) {

    if ( dest[sym__nodeType_] !== 1 || !jQuery.hasData( src ) ) {
        return;
    }

    var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData[sym__events_];

    if ( events ) {
        delete curData[sym__handle_];
        curData[sym__events_] = {};

        for ( type in events ) {
            for ( i = 0, l = events[ type ][sym__length_]; i < l; i++ ) {
                jQuery[sym__event_][sym__add_]( dest, type, events[ type ][ i ] );
            }
        }
    }

    // make the cloned public data object a copy from the original
    if ( curData[sym__data_] ) {
        curData[sym__data_] = jQuery[sym__extend_]( {}, curData[sym__data_] );
    }
}

function cloneFixAttributes( src, dest ) {
    var nodeName;

    // We do not need to do anything for non-Elements
    if ( dest[sym__nodeType_] !== 1 ) {
        return;
    }

    // clearAttributes removes the attributes, which we don't want,
    // but also removes the attachEvent events, which we *do* want
    if ( dest[sym__clearAttributes_] ) {
        dest[sym__clearAttributes_]();
    }

    // mergeAttributes, in contrast, only merges back on the
    // original attributes, not the events
    if ( dest[sym__mergeAttributes_] ) {
        dest[sym__mergeAttributes_]( src );
    }

    nodeName = dest[sym__nodeName_][sym__toLowerCase_]();

    if ( nodeName === sym__object_ ) {
        // IE6-10 improperly clones children of object elements using classid.
        // IE10 throws NoModificationAllowedError if parent is null, #12132.
        if ( dest[sym__parentNode_] ) {
            dest[sym__outerHTML_] = src[sym__outerHTML_];
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( jQuery[sym__support_][sym__html5Clone_] && (src[sym__innerHTML_] && !jQuery[sym__trim_](dest[sym__innerHTML_])) ) {
            dest[sym__innerHTML_] = src[sym__innerHTML_];
        }

    } else if ( nodeName === sym__input_ && rcheckableType[sym__test_]( src[sym__type_] ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn't also set

        dest[sym__defaultChecked_] = dest[sym__checked_] = src[sym__checked_];

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of "on"
        if ( dest[sym__value_] !== src[sym__value_] ) {
            dest[sym__value_] = src[sym__value_];
        }

    // IE6-8 fails to return the selected option to the default selected
    // state when cloning options
    } else if ( nodeName === sym__option_ ) {
        dest[sym__selected_] = src.defaultSelected;

    // IE6-8 fails to set the defaultValue to the correct value when
    // cloning other types of input fields
    } else if ( nodeName === sym__input_ || nodeName === "textarea" ) {
        dest[sym__defaultValue_] = src[sym__defaultValue_];

    // IE blanks contents when cloning scripts
    } else if ( nodeName === sym__script_ && dest[sym__text_] !== src[sym__text_] ) {
        dest[sym__text_] = src[sym__text_];
    }

    // Event data gets referenced instead of copied if the expando
    // gets copied too
    dest[sym__removeAttribute_]( jQuery[sym__expando_] );
}

jQuery[sym__buildFragment_] = function( args, context, scripts ) {
    var fragment, cacheable, cachehit,
        first = args[ 0 ];

    // Set context from what may come in as undefined or a jQuery collection or a node
    // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
    // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
    context = context || document;
    context = !context[sym__nodeType_] && context[0] || context;
    context = context[sym__ownerDocument_] || context;

    // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
    // Cloning options loses the selected state, so don't cache them
    // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
    // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
    // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
    if ( args[sym__length_] === 1 && typeof first === sym__string_ && first[sym__length_] < 512 && context === document &&
        first[sym__charAt_](0) === "<" && !rnocache[sym__test_]( first ) &&
        (jQuery[sym__support_][sym__checkClone_] || !rchecked[sym__test_]( first )) &&
        (jQuery[sym__support_][sym__html5Clone_] || !rnoshimcache[sym__test_]( first )) ) {

        // Mark cacheable and look for a hit
        cacheable = sym__g_true_;
        fragment = jQuery[sym__fragments_][ first ];
        cachehit = fragment !== undefined;
    }

    if ( !fragment ) {
        fragment = context[sym__createDocumentFragment_]();
        jQuery[sym__clean_]( args, context, fragment, scripts );

        // Update the cache, but only store false
        // unless this is a second parsing of the same content
        if ( cacheable ) {
            jQuery[sym__fragments_][ first ] = cachehit && fragment;
        }
    }

    return { fragment: fragment, cacheable: cacheable };
};

jQuery[sym__fragments_] = {};

jQuery[sym__each_]({
    appendTo: sym__append_,
    prependTo: "prepend",
    insertBefore: sym__before_,
    insertAfter: "after",
    replaceAll: sym__replaceWith_
}, function( name, original ) {
    jQuery[sym__fn_][ name ] = function( selector ) {
        var elems,
            i = 0,
            ret = [],
            insert = jQuery( selector ),
            l = insert[sym__length_],
            parent = this[sym__length_] === 1 && this[0][sym__parentNode_];

        if ( (parent == sym__g_null_ || parent && parent[sym__nodeType_] === 11 && parent[sym__childNodes_][sym__length_] === 1) && l === 1 ) {
            insert[ original ]( this[0] );
            return this;
        } else {
            for ( ; i < l; i++ ) {
                elems = ( i > 0 ? this[sym__clone_](sym__g_true_) : this )[sym__get_]();
                jQuery( insert[i] )[ original ]( elems );
                ret = ret[sym__concat_]( elems );
            }

            return this[sym__pushStack_]( ret, name, insert[sym__selector_] );
        }
    };
});

function getAll( elem ) {
    if ( typeof elem[sym__getElementsByTagName_] !== sym__undefined_ ) {
        return elem[sym__getElementsByTagName_]( "*" );

    } else if ( typeof elem[sym__querySelectorAll_] !== sym__undefined_ ) {
        return elem[sym__querySelectorAll_]( "*" );

    } else {
        return [];
    }
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType[sym__test_]( elem[sym__type_] ) ) {
        elem[sym__defaultChecked_] = elem[sym__checked_];
    }
}

jQuery[sym__extend_]({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var srcElements,
            destElements,
            i,
            clone;

        if ( jQuery[sym__support_][sym__html5Clone_] || jQuery[sym__isXMLDoc_](elem) || !rnoshimcache[sym__test_]( "<" + elem[sym__nodeName_] + ">" ) ) {
            clone = elem[sym__cloneNode_]( sym__g_true_ );

        // IE<=8 does not properly clone detached, unknown element nodes
        } else {
            fragmentDiv[sym__innerHTML_] = elem[sym__outerHTML_];
            fragmentDiv[sym__removeChild_]( clone = fragmentDiv[sym__firstChild_] );
        }

        if ( (!jQuery[sym__support_][sym__noCloneEvent_] || !jQuery[sym__support_][sym__noCloneChecked_]) &&
                (elem[sym__nodeType_] === 1 || elem[sym__nodeType_] === 11) && !jQuery[sym__isXMLDoc_](elem) ) {
            // IE copies events bound via attachEvent when using cloneNode.
            // Calling detachEvent on the clone will also remove the events
            // from the original. In order to get around this, we use some
            // proprietary methods to clear the events. Thanks to MooTools
            // guys for this hotness.

            cloneFixAttributes( elem, clone );

            // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
            srcElements = getAll( elem );
            destElements = getAll( clone );

            // Weird iteration because IE will replace the length property
            // with an element if you are cloning the body and one of the
            // elements on the page has a name or id of "length"
            for ( i = 0; srcElements[i]; ++i ) {
                // Ensure that the destination node is not null; Fixes #9587
                if ( destElements[i] ) {
                    cloneFixAttributes( srcElements[i], destElements[i] );
                }
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            cloneCopyEvent( elem, clone );

            if ( deepDataAndEvents ) {
                srcElements = getAll( elem );
                destElements = getAll( clone );

                for ( i = 0; srcElements[i]; ++i ) {
                    cloneCopyEvent( srcElements[i], destElements[i] );
                }
            }
        }

        srcElements = destElements = sym__g_null_;

        // Return the cloned set
        return clone;
    },

    clean: function( elems, context, fragment, scripts ) {
        var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
            safe = context === document && safeFragment,
            ret = [];

        // Ensure that context is a document
        if ( !context || typeof context[sym__createDocumentFragment_] === sym__undefined_ ) {
            context = document;
        }

        // Use the already-created safe fragment if context permits
        for ( i = 0; (elem = elems[i]) != sym__g_null_; i++ ) {
            if ( typeof elem === sym__number_ ) {
                elem += "";
            }

            if ( !elem ) {
                continue;
            }

            // Convert html string into DOM nodes
            if ( typeof elem === sym__string_ ) {
                if ( !rhtml[sym__test_]( elem ) ) {
                    elem = context[sym__createTextNode_]( elem );
                } else {
                    // Ensure a safe container in which to render the html
                    safe = safe || createSafeFragment( context );
                    div = context[sym__createElement_](sym__div_);
                    safe[sym__appendChild_]( div );

                    // Fix "XHTML"-style tags in all browsers
                    elem = elem[sym__replace_](rxhtmlTag, "<$1></$2>");

                    // Go to html and back, then peel off extra wrappers
                    tag = ( rtagName[sym__exec_]( elem ) || ["", ""] )[1][sym__toLowerCase_]();
                    wrap = wrapMap[ tag ] || wrapMap._default;
                    depth = wrap[0];
                    div[sym__innerHTML_] = wrap[1] + elem + wrap[2];

                    // Move to the right depth
                    while ( depth-- ) {
                        div = div[sym__lastChild_];
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !jQuery[sym__support_][sym__tbody_] ) {

                        // String was a <table>, *may* have spurious <tbody>
                        hasBody = rtbody[sym__test_](elem);
                            tbody = tag === "table" && !hasBody ?
                                div[sym__firstChild_] && div[sym__firstChild_][sym__childNodes_] :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ?
                                    div[sym__childNodes_] :
                                    [];

                        for ( j = tbody[sym__length_] - 1; j >= 0 ; --j ) {
                            if ( jQuery[sym__nodeName_]( tbody[ j ], sym__tbody_ ) && !tbody[ j ][sym__childNodes_][sym__length_] ) {
                                tbody[ j ][sym__parentNode_][sym__removeChild_]( tbody[ j ] );
                            }
                        }
                    }

                    // IE completely kills leading whitespace when innerHTML is used
                    if ( !jQuery[sym__support_][sym__leadingWhitespace_] && rleadingWhitespace[sym__test_]( elem ) ) {
                        div[sym__insertBefore_]( context[sym__createTextNode_]( rleadingWhitespace[sym__exec_](elem)[0] ), div[sym__firstChild_] );
                    }

                    elem = div[sym__childNodes_];

                    // Take out of fragment container (we need a fresh div each time)
                    div[sym__parentNode_][sym__removeChild_]( div );
                }
            }

            if ( elem[sym__nodeType_] ) {
                ret[sym__push_]( elem );
            } else {
                jQuery[sym__merge_]( ret, elem );
            }
        }

        // Fix #11356: Clear elements from safeFragment
        if ( div ) {
            elem = div = safe = sym__g_null_;
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !jQuery[sym__support_][sym__appendChecked_] ) {
            for ( i = 0; (elem = ret[i]) != sym__g_null_; i++ ) {
                if ( jQuery[sym__nodeName_]( elem, sym__input_ ) ) {
                    fixDefaultChecked( elem );
                } else if ( typeof elem[sym__getElementsByTagName_] !== sym__undefined_ ) {
                    jQuery[sym__grep_]( elem[sym__getElementsByTagName_](sym__input_), fixDefaultChecked );
                }
            }
        }

        // Append elements to a provided document fragment
        if ( fragment ) {
            // Special handling of each script element
            handleScript = function( elem ) {
                // Check if we consider it executable
                if ( !elem[sym__type_] || rscriptType[sym__test_]( elem[sym__type_] ) ) {
                    // Detach the script and store it in the scripts array (if provided) or the fragment
                    // Return truthy to indicate that it has been handled
                    return scripts ?
                        scripts[sym__push_]( elem[sym__parentNode_] ? elem[sym__parentNode_][sym__removeChild_]( elem ) : elem ) :
                        fragment[sym__appendChild_]( elem );
                }
            };

            for ( i = 0; (elem = ret[i]) != sym__g_null_; i++ ) {
                // Check if we're done after handling an executable script
                if ( !( jQuery[sym__nodeName_]( elem, sym__script_ ) && handleScript( elem ) ) ) {
                    // Append to fragment and handle embedded scripts
                    fragment[sym__appendChild_]( elem );
                    if ( typeof elem[sym__getElementsByTagName_] !== sym__undefined_ ) {
                        // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
                        jsTags = jQuery[sym__grep_]( jQuery[sym__merge_]( [], elem[sym__getElementsByTagName_](sym__script_) ), handleScript );

                        // Splice the scripts into ret after their former ancestor and advance our index beyond them
                        ret[sym__splice_][sym__apply_]( ret, [i + 1, 0][sym__concat_]( jsTags ) );
                        i += jsTags[sym__length_];
                    }
                }
            }
        }

        return ret;
    },

    cleanData: function( elems, /* internal */ acceptData ) {
        var data, id, elem, type,
            i = 0,
            internalKey = jQuery[sym__expando_],
            cache = jQuery[sym__cache_],
            deleteExpando = jQuery[sym__support_][sym__deleteExpando_],
            special = jQuery[sym__event_][sym__special_];

        for ( ; (elem = elems[i]) != sym__g_null_; i++ ) {

            if ( acceptData || jQuery[sym__acceptData_]( elem ) ) {

                id = elem[ internalKey ];
                data = id && cache[ id ];

                if ( data ) {
                    if ( data[sym__events_] ) {
                        for ( type in data[sym__events_] ) {
                            if ( special[ type ] ) {
                                jQuery[sym__event_][sym__remove_]( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery[sym__removeEvent_]( elem, type, data[sym__handle_] );
                            }
                        }
                    }

                    // Remove cache only if it was not already removed by jQuery.event.remove
                    if ( cache[ id ] ) {

                        delete cache[ id ];

                        // IE does not allow us to delete expando properties from nodes,
                        // nor does it have a removeAttribute function on Document nodes;
                        // we must handle all of these cases
                        if ( deleteExpando ) {
                            delete elem[ internalKey ];

                        } else if ( elem[sym__removeAttribute_] ) {
                            elem[sym__removeAttribute_]( internalKey );

                        } else {
                            elem[ internalKey ] = sym__g_null_;
                        }

                        jQuery[sym__deletedIds_][sym__push_]( id );
                    }
                }
            }
        }
    }
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
    ua = ua[sym__toLowerCase_]();

    var match = /(chrome)[ \/]([\w.]+)/[sym__exec_]( ua ) ||
        /(webkit)[ \/]([\w.]+)/[sym__exec_]( ua ) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/[sym__exec_]( ua ) ||
        /(msie) ([\w.]+)/[sym__exec_]( ua ) ||
        ua[sym__indexOf_]("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/[sym__exec_]( ua ) ||
        [];

    return {
        browser: match[ 1 ] || "",
        version: match[ 2 ] || "0"
    };
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched[sym__browser_] ) {
    browser[ matched[sym__browser_] ] = sym__g_true_;
    browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
    browser.webkit = sym__g_true_;
} else if ( browser.webkit ) {
    browser.safari = sym__g_true_;
}

jQuery[sym__browser_] = browser;

jQuery.sub = function() {
    function jQuerySub( selector, context ) {
        return new jQuerySub[sym__fn_][sym__init_]( selector, context );
    }
    jQuery[sym__extend_]( sym__g_true_, jQuerySub, this );
    jQuerySub.superclass = this;
    jQuerySub[sym__fn_] = jQuerySub[sym__prototype_] = this();
    jQuerySub[sym__fn_][sym__constructor_] = jQuerySub;
    jQuerySub.sub = this.sub;
    jQuerySub[sym__fn_][sym__init_] = function init( selector, context ) {
        if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
            context = jQuerySub( context );
        }

        return jQuery[sym__fn_][sym__init_][sym__call_]( this, selector, context, rootjQuerySub );
    };
    jQuerySub[sym__fn_][sym__init_][sym__prototype_] = jQuerySub[sym__fn_];
    var rootjQuerySub = jQuerySub(document);
    return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
    ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity=([^)]*)/,
    rposition = /^(top|right|bottom|left)$/,
    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rmargin = /^margin/,
    rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
    rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
    rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
    elemdisplay = { BODY: sym__block_ },

    cssShow = { position: "absolute", visibility: sym__hidden_, display: sym__block_ },
    cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    },

    cssExpand = [ "Top", "Right", "Bottom", "Left" ],
    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

    eventsToggle = jQuery[sym__fn_][sym__toggle_];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name[sym__charAt_](0)[sym__toUpperCase_]() + name[sym__slice_](1),
        origName = name,
        i = cssPrefixes[sym__length_];

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function isHidden( elem, el ) {
    elem = el || elem;
    return jQuery[sym__css_]( elem, sym__display_ ) === sym__none_ || !jQuery[sym__contains_]( elem[sym__ownerDocument_], elem );
}

function showHide( elements, show ) {
    var elem, display,
        values = [],
        index = 0,
        length = elements[sym__length_];

    for ( ; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem[sym__style_] ) {
            continue;
        }
        values[ index ] = jQuery._data( elem, sym__olddisplay_ );
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] && elem[sym__style_][sym__display_] === sym__none_ ) {
                elem[sym__style_][sym__display_] = "";
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem[sym__style_][sym__display_] === "" && isHidden( elem ) ) {
                values[ index ] = jQuery._data( elem, sym__olddisplay_, css_defaultDisplay(elem[sym__nodeName_]) );
            }
        } else {
            display = curCSS( elem, sym__display_ );

            if ( !values[ index ] && display !== sym__none_ ) {
                jQuery._data( elem, sym__olddisplay_, display );
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem[sym__style_] ) {
            continue;
        }
        if ( !show || elem[sym__style_][sym__display_] === sym__none_ || elem[sym__style_][sym__display_] === "" ) {
            elem[sym__style_][sym__display_] = show ? values[ index ] || "" : sym__none_;
        }
    }

    return elements;
}

jQuery[sym__fn_][sym__extend_]({
    css: function( name, value ) {
        return jQuery[sym__access_]( this, function( elem, name, value ) {
            return value !== undefined ?
                jQuery[sym__style_]( elem, name, value ) :
                jQuery[sym__css_]( elem, name );
        }, name, value, arguments[sym__length_] > 1 );
    },
    show: function() {
        return showHide( this, sym__g_true_ );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state, fn2 ) {
        var bool = typeof state === sym__boolean_;

        if ( jQuery[sym__isFunction_]( state ) && jQuery[sym__isFunction_]( fn2 ) ) {
            return eventsToggle[sym__apply_]( this, arguments );
        }

        return this[sym__each_](function() {
            if ( bool ? state : isHidden( this ) ) {
                jQuery( this )[sym__show_]();
            } else {
                jQuery( this )[sym__hide_]();
            }
        });
    }
});

jQuery[sym__extend_]({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, sym__opacity_ );
                    return ret === "" ? "1" : ret;

                }
            }
        }
    },

    // Exclude the following css properties to add px
    cssNumber: {
        "fillOpacity": sym__g_true_,
        "fontWeight": sym__g_true_,
        "lineHeight": sym__g_true_,
        "opacity": sym__g_true_,
        "orphans": sym__g_true_,
        "widows": sym__g_true_,
        "zIndex": sym__g_true_,
        "zoom": sym__g_true_
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        "float": jQuery[sym__support_][sym__cssFloat_] ? "cssFloat" : "styleFloat"
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don't set styles on text and comment nodes
        if ( !elem || elem[sym__nodeType_] === 3 || elem[sym__nodeType_] === 8 || !elem[sym__style_] ) {
            return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
            origName = jQuery[sym__camelCase_]( name ),
            style = elem[sym__style_];

        name = jQuery[sym__cssProps_][ origName ] || ( jQuery[sym__cssProps_][ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery[sym__cssHooks_][ name ] || jQuery[sym__cssHooks_][ origName ];

        // Check if we're setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === sym__string_ && (ret = rrelNum[sym__exec_]( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery[sym__css_]( elem, name ) );
                // Fixes bug #9237
                type = sym__number_;
            }

            // Make sure that NaN and null values aren't set. See: #7116
            if ( value == sym__g_null_ || type === sym__number_ && isNaN( value ) ) {
                return;
            }

            // If a number was passed in, add 'px' to the (except for certain CSS properties)
            if ( type === sym__number_ && !jQuery[sym__cssNumber_][ origName ] ) {
                value += sym__px_;
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !(sym__set_ in hooks) || (value = hooks[sym__set_]( elem, value, extra )) !== undefined ) {
                // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                // Fixes bug #5509
                try {
                    style[ name ] = value;
                } catch(e) {}
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks && sym__get_ in hooks && (ret = hooks[sym__get_]( elem, sym__g_false_, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, numeric, extra ) {
        var val, num, hooks,
            origName = jQuery[sym__camelCase_]( name );

        // Make sure that we're working with the right name
        name = jQuery[sym__cssProps_][ origName ] || ( jQuery[sym__cssProps_][ origName ] = vendorPropName( elem[sym__style_], origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery[sym__cssHooks_][ name ] || jQuery[sym__cssHooks_][ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks && sym__get_ in hooks ) {
            val = hooks[sym__get_]( elem, sym__g_true_, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name );
        }

        //convert "normal" to computed value
        if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( numeric || extra !== undefined ) {
            num = parseFloat( val );
            return numeric || jQuery[sym__isNumeric_]( num ) ? num || 0 : val;
        }
        return val;
    },

    // A method for quickly swapping in/out CSS properties to get correct calculations
    swap: function( elem, options, callback ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem[sym__style_][ name ];
            elem[sym__style_][ name ] = options[ name ];
        }

        ret = callback[sym__call_]( elem );

        // Revert the old values
        for ( name in options ) {
            elem[sym__style_][ name ] = old[ name ];
        }

        return ret;
    }
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( sym__g_window_[sym__getComputedStyle_] ) {
    curCSS = function( elem, name ) {
        var ret, width, minWidth, maxWidth,
            computed = sym__g_window_[sym__getComputedStyle_]( elem, sym__g_null_ ),
            style = elem[sym__style_];

        if ( computed ) {

            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
            ret = computed.getPropertyValue( name ) || computed[ name ];

            if ( ret === "" && !jQuery[sym__contains_]( elem[sym__ownerDocument_], elem ) ) {
                ret = jQuery[sym__style_]( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx[sym__test_]( ret ) && rmargin[sym__test_]( name ) ) {
                width = style[sym__width_];
                minWidth = style[sym__minWidth_];
                maxWidth = style[sym__maxWidth_];

                style[sym__minWidth_] = style[sym__maxWidth_] = style[sym__width_] = ret;
                ret = computed[sym__width_];

                style[sym__width_] = width;
                style[sym__minWidth_] = minWidth;
                style[sym__maxWidth_] = maxWidth;
            }
        }

        return ret;
    };
} else if ( document[sym__documentElement_][sym__currentStyle_] ) {
    curCSS = function( elem, name ) {
        var left, rsLeft,
            ret = elem[sym__currentStyle_] && elem[sym__currentStyle_][ name ],
            style = elem[sym__style_];

        // Avoid setting ret to empty string here
        // so we don't default to auto
        if ( ret == sym__g_null_ && style && style[ name ] ) {
            ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
        if ( rnumnonpx[sym__test_]( ret ) && !rposition[sym__test_]( name ) ) {

            // Remember the original values
            left = style[sym__left_];
            rsLeft = elem[sym__runtimeStyle_] && elem[sym__runtimeStyle_][sym__left_];

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                elem[sym__runtimeStyle_][sym__left_] = elem[sym__currentStyle_][sym__left_];
            }
            style[sym__left_] = name === "fontSize" ? "1em" : ret;
            ret = style.pixelLeft + sym__px_;

            // Revert the changed values
            style[sym__left_] = left;
            if ( rsLeft ) {
                elem[sym__runtimeStyle_][sym__left_] = rsLeft;
            }
        }

        return ret === "" ? "auto" : ret;
    };
}

function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit[sym__exec_]( value );
    return matches ?
            Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || sym__px_ ) :
            value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
    var i = extra === ( isBorderBox ? "border" : sym__content_ ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === sym__width_ ? 1 : 0,

        val = 0;

    for ( ; i < 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === sym__margin_ ) {
            // we use jQuery.css instead of curCSS here
            // because of the reliableMarginRight CSS hook!
            val += jQuery[sym__css_]( elem, extra + cssExpand[ i ], sym__g_true_ );
        }

        // From this point on we use curCSS for maximum performance (relevant in animations)
        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === sym__content_ ) {
                val -= parseFloat( curCSS( elem, sym__padding_ + cssExpand[ i ] ) ) || 0;
            }

            // at this point, extra isn't border nor margin, so remove border
            if ( extra !== sym__margin_ ) {
                val -= parseFloat( curCSS( elem, sym__border_ + cssExpand[ i ] + sym__Width_ ) ) || 0;
            }
        } else {
            // at this point, extra isn't content, so add padding
            val += parseFloat( curCSS( elem, sym__padding_ + cssExpand[ i ] ) ) || 0;

            // at this point, extra isn't content nor padding, so add border
            if ( extra !== sym__padding_ ) {
                val += parseFloat( curCSS( elem, sym__border_ + cssExpand[ i ] + sym__Width_ ) ) || 0;
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var val = name === sym__width_ ? elem[sym__offsetWidth_] : elem[sym__offsetHeight_],
        valueIsBorderBox = sym__g_true_,
        isBorderBox = jQuery[sym__support_][sym__boxSizing_] && jQuery[sym__css_]( elem, sym__boxSizing_ ) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val <= 0 || val == sym__g_null_ ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name );
        if ( val < 0 || val == sym__g_null_ ) {
            val = elem[sym__style_][ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx[sym__test_](val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && ( jQuery[sym__support_][sym__boxSizingReliable_] || val === elem[sym__style_][ name ] );

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? "border" : sym__content_ ),
            valueIsBorderBox
        )
    ) + sym__px_;
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
    if ( elemdisplay[ nodeName ] ) {
        return elemdisplay[ nodeName ];
    }

    var elem = jQuery( "<" + nodeName + ">" ).appendTo( document[sym__body_] ),
        display = elem[sym__css_](sym__display_);
    elem[sym__remove_]();

    // If the simple way fails,
    // get element's real default display by attaching it to a temp iframe
    if ( display === sym__none_ || display === "" ) {
        // Use the already-created iframe if possible
        iframe = document[sym__body_][sym__appendChild_](
            iframe || jQuery[sym__extend_]( document[sym__createElement_]("iframe"), {
                frameBorder: 0,
                width: 0,
                height: 0
            })
        );

        // Create a cacheable copy of the iframe document on first call.
        // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
        // document to it; WebKit & Firefox won't allow reusing the iframe document.
        if ( !iframeDoc || !iframe[sym__createElement_] ) {
            iframeDoc = ( iframe[sym__contentWindow_] || iframe[sym__contentDocument_] )[sym__document_];
            iframeDoc.write("<!doctype html><html><body>");
            iframeDoc.close();
        }

        elem = iframeDoc[sym__body_][sym__appendChild_]( iframeDoc[sym__createElement_](nodeName) );

        display = curCSS( elem, sym__display_ );
        document[sym__body_][sym__removeChild_]( iframe );
    }

    // Store the correct default display
    elemdisplay[ nodeName ] = display;

    return display;
}

jQuery[sym__each_]([ sym__height_, sym__width_ ], function( i, name ) {
    jQuery[sym__cssHooks_][ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                if ( elem[sym__offsetWidth_] === 0 && rdisplayswap[sym__test_]( curCSS( elem, sym__display_ ) ) ) {
                    return jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    });
                } else {
                    return getWidthOrHeight( elem, name, extra );
                }
            }
        },

        set: function( elem, value, extra ) {
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    jQuery[sym__support_][sym__boxSizing_] && jQuery[sym__css_]( elem, sym__boxSizing_ ) === "border-box"
                ) : 0
            );
        }
    };
});

if ( !jQuery[sym__support_][sym__opacity_] ) {
    jQuery[sym__cssHooks_][sym__opacity_] = {
        get: function( elem, computed ) {
            // IE uses filters for opacity
            return ropacity[sym__test_]( (computed && elem[sym__currentStyle_] ? elem[sym__currentStyle_][sym__filter_] : elem[sym__style_][sym__filter_]) || "" ) ?
                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                computed ? "1" : "";
        },

        set: function( elem, value ) {
            var style = elem[sym__style_],
                currentStyle = elem[sym__currentStyle_],
                opacity = jQuery[sym__isNumeric_]( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                filter = currentStyle && currentStyle[sym__filter_] || style[sym__filter_] || "";

            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style[sym__zoom_] = 1;

            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            if ( value >= 1 && jQuery[sym__trim_]( filter[sym__replace_]( ralpha, "" ) ) === "" &&
                style[sym__removeAttribute_] ) {

                // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                // if "filter:" is present at all, clearType is disabled, we want to avoid this
                // style.removeAttribute is IE Only, but so apparently is this code path...
                style[sym__removeAttribute_]( sym__filter_ );

                // if there there is no filter style applied in a css rule, we are done
                if ( currentStyle && !currentStyle[sym__filter_] ) {
                    return;
                }
            }

            // otherwise, set new filter values
            style[sym__filter_] = ralpha[sym__test_]( filter ) ?
                filter[sym__replace_]( ralpha, opacity ) :
                filter + " " + opacity;
        }
    };
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
    if ( !jQuery[sym__support_][sym__reliableMarginRight_] ) {
        jQuery[sym__cssHooks_][sym__marginRight_] = {
            get: function( elem, computed ) {
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // Work around by temporarily setting element display to inline-block
                return jQuery.swap( elem, { "display": "inline-block" }, function() {
                    if ( computed ) {
                        return curCSS( elem, sym__marginRight_ );
                    }
                });
            }
        };
    }

    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    if ( !jQuery[sym__support_][sym__pixelPosition_] && jQuery[sym__fn_][sym__position_] ) {
        jQuery[sym__each_]( [ sym__top_, sym__left_ ], function( i, prop ) {
            jQuery[sym__cssHooks_][ prop ] = {
                get: function( elem, computed ) {
                    if ( computed ) {
                        var ret = curCSS( elem, prop );
                        // if curCSS returns percentage, fallback to offset
                        return rnumnonpx[sym__test_]( ret ) ? jQuery( elem )[sym__position_]()[ prop ] + "px" : ret;
                    }
                }
            };
        });
    }

});

if ( jQuery[sym__expr_] && jQuery[sym__expr_][sym__filters_] ) {
    jQuery[sym__expr_][sym__filters_][sym__hidden_] = function( elem ) {
        return ( elem[sym__offsetWidth_] === 0 && elem[sym__offsetHeight_] === 0 ) || (!jQuery[sym__support_][sym__reliableHiddenOffsets_] && ((elem[sym__style_] && elem[sym__style_][sym__display_]) || curCSS( elem, sym__display_ )) === sym__none_);
    };

    jQuery[sym__expr_][sym__filters_].visible = function( elem ) {
        return !jQuery[sym__expr_][sym__filters_][sym__hidden_]( elem );
    };
}

// These hooks are used by animate to expand properties
jQuery[sym__each_]({
    margin: "",
    padding: "",
    border: sym__Width_
}, function( prefix, suffix ) {
    jQuery[sym__cssHooks_][ prefix + suffix ] = {
        expand: function( value ) {
            var i,

                // assumes a single number if not a string
                parts = typeof value === sym__string_ ? value[sym__split_](" ") : [ value ],
                expanded = {};

            for ( i = 0; i < 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin[sym__test_]( prefix ) ) {
        jQuery[sym__cssHooks_][ prefix + suffix ][sym__set_] = setPositiveNumber;
    }
});
var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    rselectTextarea = /^(?:select|textarea)/i;

jQuery[sym__fn_][sym__extend_]({
    serialize: function() {
        return jQuery[sym__param_]( this.serializeArray() );
    },
    serializeArray: function() {
        return this[sym__map_](function(){
            return this.elements ? jQuery[sym__makeArray_]( this.elements ) : this;
        })
        [sym__filter_](function(){
            return this[sym__name_] && !this[sym__disabled_] &&
                ( this[sym__checked_] || rselectTextarea[sym__test_]( this[sym__nodeName_] ) ||
                    rinput[sym__test_]( this[sym__type_] ) );
        })
        [sym__map_](function( i, elem ){
            var val = jQuery( this ).val();

            return val == sym__g_null_ ?
                sym__g_null_ :
                jQuery[sym__isArray_]( val ) ?
                    jQuery[sym__map_]( val, function( val, i ){
                        return { name: elem[sym__name_], value: val[sym__replace_]( rCRLF, "\r\n" ) };
                    }) :
                    { name: elem[sym__name_], value: val[sym__replace_]( rCRLF, "\r\n" ) };
        })[sym__get_]();
    }
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery[sym__param_] = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery[sym__isFunction_]( value ) ? value() : ( value == sym__g_null_ ? "" : value );
            s[ s[sym__length_] ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery[sym__ajaxSettings_] && jQuery[sym__ajaxSettings_][sym__traditional_];
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery[sym__isArray_]( a ) || ( a[sym__jquery_] && !jQuery[sym__isPlainObject_]( a ) ) ) {
        // Serialize the form elements
        jQuery[sym__each_]( a, function() {
            add( this[sym__name_], this[sym__value_] );
        });

    } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s[sym__join_]( "&" )[sym__replace_]( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery[sym__isArray_]( obj ) ) {
        // Serialize array item.
        jQuery[sym__each_]( obj, function( i, v ) {
            if ( traditional || rbracket[sym__test_]( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // If array item is non-scalar (array or object), encode its
                // numeric index to resolve deserialization ambiguity issues.
                // Note that rack (as of 1.0.0) can't currently deserialize
                // nested arrays properly, and attempting to do so may cause
                // a server error. Possible fixes are to modify rack's
                // deserialization algorithm or to provide an option or flag
                // to force array serialization to be shallow.
                buildParams( prefix + "[" + ( typeof v === sym__object_ ? i : "" ) + "]", v, traditional, add );
            }
        });

    } else if ( !traditional && jQuery[sym__type_]( obj ) === sym__object_ ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}
var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rquery = /\?/,
    rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    rts = /([?&])_=[^&]*/,
    rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

    // Keep a copy of the old load method
    _load = jQuery[sym__fn_].load,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location[sym__href_];
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document[sym__createElement_]( "a" );
    ajaxLocation[sym__href_] = "";
    ajaxLocation = ajaxLocation[sym__href_];
}

// Segment location into parts
ajaxLocParts = rurl[sym__exec_]( ajaxLocation[sym__toLowerCase_]() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== sym__string_ ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
        }

        var dataType, list, placeBefore,
            dataTypes = dataTypeExpression[sym__toLowerCase_]()[sym__split_]( core_rspace ),
            i = 0,
            length = dataTypes[sym__length_];

        if ( jQuery[sym__isFunction_]( func ) ) {
            // For each dataType in the dataTypeExpression
            for ( ; i < length; i++ ) {
                dataType = dataTypes[ i ];
                // We control if we're asked to add before
                // any existing element
                placeBefore = /^\+/[sym__test_]( dataType );
                if ( placeBefore ) {
                    dataType = dataType[sym__substr_]( 1 ) || "*";
                }
                list = structure[ dataType ] = structure[ dataType ] || [];
                // then we add to the structure accordingly
                list[ placeBefore ? "unshift" : sym__push_ ]( func );
            }
        }
    };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
        dataType /* internal */, inspected /* internal */ ) {

    dataType = dataType || options[sym__dataTypes_][ 0 ];
    inspected = inspected || {};

    inspected[ dataType ] = sym__g_true_;

    var selection,
        list = structure[ dataType ],
        i = 0,
        length = list ? list[sym__length_] : 0,
        executeOnly = ( structure === prefilters );

    for ( ; i < length && ( executeOnly || !selection ); i++ ) {
        selection = list[ i ]( options, originalOptions, jqXHR );
        // If we got redirected to another dataType
        // we try there if executing only and not done already
        if ( typeof selection === sym__string_ ) {
            if ( !executeOnly || inspected[ selection ] ) {
                selection = undefined;
            } else {
                options[sym__dataTypes_][sym__unshift_]( selection );
                selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected );
            }
        }
    }
    // If we're only executing or nothing was selected
    // we try the catchall dataType if not done already
    if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
        selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected );
    }
    // unnecessary when only executing (prefilters)
    // but it'll be ignored by the caller in that case
    return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var key, deep,
        flatOptions = jQuery[sym__ajaxSettings_].flatOptions || {};
    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery[sym__extend_]( sym__g_true_, target, deep );
    }
}

jQuery[sym__fn_].load = function( url, params, callback ) {
    if ( typeof url !== sym__string_ && _load ) {
        return _load[sym__apply_]( this, arguments );
    }

    // Don't do a request if no elements are being requested
    if ( !this[sym__length_] ) {
        return this;
    }

    var selector, type, response,
        self = this,
        off = url[sym__indexOf_](" ");

    if ( off >= 0 ) {
        selector = url[sym__slice_]( off, url[sym__length_] );
        url = url[sym__slice_]( 0, off );
    }

    // If it's a function
    if ( jQuery[sym__isFunction_]( params ) ) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params && typeof params === sym__object_ ) {
        type = "POST";
    }

    // Request the remote document
    jQuery[sym__ajax_]({
        url: url,

        // if "type" variable is undefined, then "GET" method will be used
        type: type,
        dataType: sym__html_,
        data: params,
        complete: function( jqXHR, status ) {
            if ( callback ) {
                self[sym__each_]( callback, response || [ jqXHR[sym__responseText_], status, jqXHR ] );
            }
        }
    })[sym__done_](function( responseText ) {

        // Save response for use in complete callback
        response = arguments;

        // See if a selector was specified
        self[sym__html_]( selector ?

            // Create a dummy div to hold the results
            jQuery("<div>")

                // inject the contents of the document in, removing the scripts
                // to avoid any 'Permission Denied' errors in IE
                [sym__append_]( responseText[sym__replace_]( rscript, "" ) )

                // Locate the specified elements
                [sym__find_]( selector ) :

            // If not, just inject the full result
            responseText );

    });

    return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery[sym__each_]( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend"[sym__split_]( " " ), function( i, o ){
    jQuery[sym__fn_][ o ] = function( f ){
        return this[sym__on_]( o, f );
    };
});

jQuery[sym__each_]( [ sym__get_, "post" ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery[sym__isFunction_]( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery[sym__ajax_]({
            type: method,
            url: url,
            data: data,
            success: callback,
            dataType: type
        });
    };
});

jQuery[sym__extend_]({

    getScript: function( url, callback ) {
        return jQuery[sym__get_]( url, undefined, callback, sym__script_ );
    },

    getJSON: function( url, data, callback ) {
        return jQuery[sym__get_]( url, data, callback, "json" );
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        if ( settings ) {
            // Building a settings object
            ajaxExtend( target, jQuery[sym__ajaxSettings_] );
        } else {
            // Extending ajaxSettings
            settings = target;
            target = jQuery[sym__ajaxSettings_];
        }
        ajaxExtend( target, settings );
        return target;
    },

    ajaxSettings: {
        url: ajaxLocation,
        isLocal: rlocalProtocol[sym__test_]( ajaxLocParts[ 1 ] ),
        global: sym__g_true_,
        type: "GET",
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        processData: sym__g_true_,
        async: sym__g_true_,
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            xml: "application/xml, text/xml",
            html: "text/html",
            text: "text/plain",
            json: "application/json, text/javascript",
            "*": allTypes
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: sym__responseXML_,
            text: sym__responseText_
        },

        // List of data converters
        // 1) key format is "source_type destination_type" (a single space in-between)
        // 2) the catchall symbol "*" can be used for source_type
        converters: {

            // Convert anything to text
            "* text": sym__g_window_.String,

            // Text to html (true = no transformation)
            "text html": sym__g_true_,

            // Evaluate text as a json expression
            "text json": jQuery[sym__parseJSON_],

            // Parse text as xml
            "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
            context: sym__g_true_,
            url: sym__g_true_
        }
    },

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === sym__object_ ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var // ifModified key
            ifModifiedKey,
            // Response headers
            responseHeadersString,
            responseHeaders,
            // transport
            transport,
            // timeout handle
            timeoutTimer,
            // Cross-domain detection vars
            parts,
            // To know if global events are to be dispatched
            fireGlobals,
            // Loop variable
            i,
            // Create the final options object
            s = jQuery[sym__ajaxSetup_]( {}, options ),
            // Callbacks context
            callbackContext = s[sym__context_] || s,
            // Context for global events
            // It's the callbackContext if one was provided in the options
            // and if it's a DOM node or a jQuery collection
            globalEventContext = callbackContext !== s &&
                ( callbackContext[sym__nodeType_] || callbackContext instanceof jQuery ) ?
                        jQuery( callbackContext ) : jQuery[sym__event_],
            // Deferreds
            deferred = jQuery[sym__Deferred_](),
            completeDeferred = jQuery[sym__Callbacks_]( "once memory" ),
            // Status-dependent callbacks
            statusCode = s[sym__statusCode_] || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {

                readyState: 0,

                // Caches the header
                setRequestHeader: function( name, value ) {
                    if ( !state ) {
                        var lname = name[sym__toLowerCase_]();
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : sym__g_null_;
                },

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while( ( match = rheaders[sym__exec_]( responseHeadersString ) ) ) {
                                responseHeaders[ match[1][sym__toLowerCase_]() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key[sym__toLowerCase_]() ];
                    }
                    return match === undefined ? sym__g_null_ : match;
                },

                // Overrides response content-type header
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s[sym__mimeType_] = type;
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    statusText = statusText || strAbort;
                    if ( transport ) {
                        transport[sym__abort_]( statusText );
                    }
                    done( 0, statusText );
                    return this;
                }
            };

        // Callback for when everything is done
        // It is defined here because jslint complains if it is declared
        // at the end of the function (which would be more logical and readable)
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is "done" now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR[sym__readyState_] = status > 0 ? 4 : 0;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // If successful, handle type chaining
            if ( status >= 200 && status < 300 || status === 304 ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s[sym__ifModified_] ) {

                    modified = jqXHR[sym__getResponseHeader_]("Last-Modified");
                    if ( modified ) {
                        jQuery[sym__lastModified_][ ifModifiedKey ] = modified;
                    }
                    modified = jqXHR[sym__getResponseHeader_]("Etag");
                    if ( modified ) {
                        jQuery.etag[ ifModifiedKey ] = modified;
                    }
                }

                // If not modified
                if ( status === 304 ) {

                    statusText = "notmodified";
                    isSuccess = sym__g_true_;

                // If we have data
                } else {

                    isSuccess = ajaxConvert( s, response );
                    statusText = isSuccess.state;
                    success = isSuccess[sym__data_];
                    error = isSuccess[sym__error_];
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( !statusText || status ) {
                    statusText = sym__error_;
                    if ( status < 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR[sym__status_] = status;
            jqXHR[sym__statusText_] = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
                deferred[sym__resolveWith_]( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred[sym__rejectWith_]( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR[sym__statusCode_]( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext[sym__trigger_]( sym__ajax_ + ( isSuccess ? "Success" : "Error" ),
                        [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred[sym__fireWith_]( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext[sym__trigger_]( "ajaxComplete", [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery[sym__active_] ) ) {
                    jQuery[sym__event_][sym__trigger_]( "ajaxStop" );
                }
            }
        }

        // Attach deferreds
        deferred[sym__promise_]( jqXHR );
        jqXHR[sym__success_] = jqXHR[sym__done_];
        jqXHR[sym__error_] = jqXHR[sym__fail_];
        jqXHR[sym__complete_] = completeDeferred[sym__add_];

        // Status-dependent callbacks
        jqXHR[sym__statusCode_] = function( map ) {
            if ( map ) {
                var tmp;
                if ( state < 2 ) {
                    for ( tmp in map ) {
                        statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                    }
                } else {
                    tmp = map[ jqXHR[sym__status_] ];
                    jqXHR[sym__always_]( tmp );
                }
            }
            return this;
        };

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
        // We also use the url parameter if available
        s[sym__url_] = ( ( url || s[sym__url_] ) + "" )[sym__replace_]( rhash, "" )[sym__replace_]( rprotocol, ajaxLocParts[ 1 ] + "//" );

        // Extract dataTypes list
        s[sym__dataTypes_] = jQuery[sym__trim_]( s.dataType || "*" )[sym__toLowerCase_]()[sym__split_]( core_rspace );

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s[sym__crossDomain_] == sym__g_null_ ) {
            parts = rurl[sym__exec_]( s[sym__url_][sym__toLowerCase_]() );
            s[sym__crossDomain_] = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
            );
        }

        // Convert data if not already a string
        if ( s[sym__data_] && s.processData && typeof s[sym__data_] !== sym__string_ ) {
            s[sym__data_] = jQuery[sym__param_]( s[sym__data_], s[sym__traditional_] );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s[sym__global_];

        // Uppercase the type
        s[sym__type_] = s[sym__type_][sym__toUpperCase_]();

        // Determine if request has content
        s[sym__hasContent_] = !rnoContent[sym__test_]( s[sym__type_] );

        // Watch for a new set of requests
        if ( fireGlobals && jQuery[sym__active_]++ === 0 ) {
            jQuery[sym__event_][sym__trigger_]( "ajaxStart" );
        }

        // More options handling for requests with no content
        if ( !s[sym__hasContent_] ) {

            // If data is available, append data to url
            if ( s[sym__data_] ) {
                s[sym__url_] += ( rquery[sym__test_]( s[sym__url_] ) ? "&" : "?" ) + s[sym__data_];
                // #9682: remove data so that it's not used in an eventual retry
                delete s[sym__data_];
            }

            // Get ifModifiedKey before adding the anti-cache parameter
            ifModifiedKey = s[sym__url_];

            // Add anti-cache in url if needed
            if ( s[sym__cache_] === sym__g_false_ ) {

                var ts = jQuery[sym__now_](),
                    // try replacing _= if it is there
                    ret = s[sym__url_][sym__replace_]( rts, "$1_=" + ts );

                // if nothing was replaced, add timestamp to the end
                s[sym__url_] = ret + ( ( ret === s[sym__url_] ) ? ( rquery[sym__test_]( s[sym__url_] ) ? "&" : "?" ) + "_=" + ts : "" );
            }
        }

        // Set the correct header, if data is being sent
        if ( s[sym__data_] && s[sym__hasContent_] && s[sym__contentType_] !== sym__g_false_ || options[sym__contentType_] ) {
            jqXHR[sym__setRequestHeader_]( "Content-Type", s[sym__contentType_] );
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s[sym__ifModified_] ) {
            ifModifiedKey = ifModifiedKey || s[sym__url_];
            if ( jQuery[sym__lastModified_][ ifModifiedKey ] ) {
                jqXHR[sym__setRequestHeader_]( "If-Modified-Since", jQuery[sym__lastModified_][ ifModifiedKey ] );
            }
            if ( jQuery.etag[ ifModifiedKey ] ) {
                jqXHR[sym__setRequestHeader_]( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
            }
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR[sym__setRequestHeader_](
            "Accept",
            s[sym__dataTypes_][ 0 ] && s[sym__accepts_][ s[sym__dataTypes_][0] ] ?
                s[sym__accepts_][ s[sym__dataTypes_][0] ] + ( s[sym__dataTypes_][ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                s[sym__accepts_][ "*" ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR[sym__setRequestHeader_]( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s[sym__beforeSend_] && ( s[sym__beforeSend_][sym__call_]( callbackContext, jqXHR, s ) === sym__g_false_ || state === 2 ) ) {
                // Abort if not done already and return
                return jqXHR[sym__abort_]();

        }

        // aborting is no longer a cancellation
        strAbort = sym__abort_;

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, "No Transport" );
        } else {
            jqXHR[sym__readyState_] = 1;
            // Send global event
            if ( fireGlobals ) {
                globalEventContext[sym__trigger_]( "ajaxSend", [ jqXHR, s ] );
            }
            // Timeout
            if ( s[sym__async_] && s[sym__timeout_] > 0 ) {
                timeoutTimer = setTimeout( function(){
                    jqXHR[sym__abort_]( sym__timeout_ );
                }, s[sym__timeout_] );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch (e) {
                // Propagate exception as error if not done
                if ( state < 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        return jqXHR;
    },

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

    var ct, type, finalDataType, firstDataType,
        contents = s.contents,
        dataTypes = s[sym__dataTypes_],
        responseFields = s.responseFields;

    // Fill responseXXX fields
    for ( type in responseFields ) {
        if ( type in responses ) {
            jqXHR[ responseFields[type] ] = responses[ type ];
        }
    }

    // Remove auto dataType and get content-type in the process
    while( dataTypes[ 0 ] === "*" ) {
        dataTypes[sym__shift_]();
        if ( ct === undefined ) {
            ct = s[sym__mimeType_] || jqXHR[sym__getResponseHeader_]( "content-type" );
        }
    }

    // Check if we're dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] && contents[ type ][sym__test_]( ct ) ) {
                dataTypes[sym__unshift_]( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s[sym__converters_][ type + " " + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes[sym__unshift_]( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

    var conv, conv2, current, tmp,
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s[sym__dataTypes_][sym__slice_](),
        prev = dataTypes[ 0 ],
        converters = {},
        i = 0;

    // Apply the dataFilter if provided
    if ( s[sym__dataFilter_] ) {
        response = s[sym__dataFilter_]( response, s.dataType );
    }

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s[sym__converters_] ) {
            converters[ conv[sym__toLowerCase_]() ] = s[sym__converters_][ conv ];
        }
    }

    // Convert to each sequential dataType, tolerating list modification
    for ( ; (current = dataTypes[++i]); ) {

        // There's only work to do if current dataType is non-auto
        if ( current !== "*" ) {

            // Convert response if prev dataType is non-auto and differs from current
            if ( prev !== "*" && prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2[sym__split_](" ");
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                converters[ "* " + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === sym__g_true_ ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== sym__g_true_ ) {
                                    current = tmp[ 0 ];
                                    dataTypes[sym__splice_]( i--, 0, current );
                                }

                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== sym__g_true_ ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv && s["throws"] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: sym__parsererror_, error: conv ? e : "No conversion from " + prev + " to " + current };
                        }
                    }
                }
            }

            // Update prev for next iteration
            prev = current;
        }
    }

    return { state: sym__success_, data: response };
}
var oldCallbacks = [],
    rquestion = /\?/,
    rjsonp = /(=)\?(?=&|$)|\?\?/,
    nonce = jQuery[sym__now_]();

// Default jsonp settings
jQuery[sym__ajaxSetup_]({
    jsonp: "callback",
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery[sym__expando_] + "_" + ( nonce++ ) );
        this[ callback ] = sym__g_true_;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery[sym__ajaxPrefilter_]( "json jsonp", function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        data = s[sym__data_],
        url = s[sym__url_],
        hasCallback = s[sym__jsonp_] !== sym__g_false_,
        replaceInUrl = hasCallback && rjsonp[sym__test_]( url ),
        replaceInData = hasCallback && !replaceInUrl && typeof data === sym__string_ &&
            !( s[sym__contentType_] || "" )[sym__indexOf_]("application/x-www-form-urlencoded") &&
            rjsonp[sym__test_]( data );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( s[sym__dataTypes_][ 0 ] === sym__jsonp_ || replaceInUrl || replaceInData ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s[sym__jsonpCallback_] = jQuery[sym__isFunction_]( s[sym__jsonpCallback_] ) ?
            s[sym__jsonpCallback_]() :
            s[sym__jsonpCallback_];
        overwritten = sym__g_window_[ callbackName ];

        // Insert callback into url or form data
        if ( replaceInUrl ) {
            s[sym__url_] = url[sym__replace_]( rjsonp, "$1" + callbackName );
        } else if ( replaceInData ) {
            s[sym__data_] = data[sym__replace_]( rjsonp, "$1" + callbackName );
        } else if ( hasCallback ) {
            s[sym__url_] += ( rquestion[sym__test_]( url ) ? "&" : "?" ) + s[sym__jsonp_] + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s[sym__converters_]["script json"] = function() {
            if ( !responseContainer ) {
                jQuery[sym__error_]( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s[sym__dataTypes_][ 0 ] = "json";

        // Install callback
        sym__g_window_[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR[sym__always_](function() {
            // Restore preexisting value
            sym__g_window_[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn't screw things around
                s[sym__jsonpCallback_] = originalSettings[sym__jsonpCallback_];

                // save the callback name for future use
                oldCallbacks[sym__push_]( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && jQuery[sym__isFunction_]( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return sym__script_;
    }
});
// Install script dataType
jQuery[sym__ajaxSetup_]({
    accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
        script: /javascript|ecmascript/
    },
    converters: {
        "text script": function( text ) {
            jQuery[sym__globalEval_]( text );
            return text;
        }
    }
});

// Handle cache's special case and global
jQuery[sym__ajaxPrefilter_]( sym__script_, function( s ) {
    if ( s[sym__cache_] === undefined ) {
        s[sym__cache_] = sym__g_false_;
    }
    if ( s[sym__crossDomain_] ) {
        s[sym__type_] = "GET";
        s[sym__global_] = sym__g_false_;
    }
});

// Bind script tag hack transport
jQuery[sym__ajaxTransport_]( sym__script_, function(s) {

    // This transport only deals with cross domain requests
    if ( s[sym__crossDomain_] ) {

        var script,
            head = document.head || document[sym__getElementsByTagName_]( "head" )[0] || document[sym__documentElement_];

        return {

            send: function( _, callback ) {

                script = document[sym__createElement_]( sym__script_ );

                script[sym__async_] = sym__async_;

                if ( s[sym__scriptCharset_] ) {
                    script.charset = s[sym__scriptCharset_];
                }

                script.src = s[sym__url_];

                // Attach handlers for all browsers
                script[sym__onload_] = script[sym__onreadystatechange_] = function( _, isAbort ) {

                    if ( isAbort || !script[sym__readyState_] || /loaded|complete/[sym__test_]( script[sym__readyState_] ) ) {

                        // Handle memory leak in IE
                        script[sym__onload_] = script[sym__onreadystatechange_] = sym__g_null_;

                        // Remove the script
                        if ( head && script[sym__parentNode_] ) {
                            head[sym__removeChild_]( script );
                        }

                        // Dereference the script
                        script = undefined;

                        // Callback if not abort
                        if ( !isAbort ) {
                            callback( 200, sym__success_ );
                        }
                    }
                };
                // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                // This arises when a base node is used (#2709 and #4378).
                head[sym__insertBefore_]( script, head[sym__firstChild_] );
            },

            abort: function() {
                if ( script ) {
                    script[sym__onload_]( 0, 1 );
                }
            }
        };
    }
});
var xhrCallbacks,
    // #5280: Internet Explorer will keep connections alive if we don't abort on unload
    xhrOnUnloadAbort = sym__g_window_[sym__ActiveXObject_] ? function() {
        // Abort all pending requests
        for ( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]( 0, 1 );
        }
    } : sym__g_false_,
    xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
    try {
        return new sym__g_window_[sym__XMLHttpRequest_]();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new sym__g_window_[sym__ActiveXObject_]( "Microsoft.XMLHTTP" );
    } catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery[sym__ajaxSettings_].xhr = sym__g_window_[sym__ActiveXObject_] ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */
    function() {
        return !this.isLocal && createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

// Determine support properties
(function( xhr ) {
    jQuery[sym__extend_]( jQuery[sym__support_], {
        ajax: !!xhr,
        cors: !!xhr && ( "withCredentials" in xhr )
    });
})( jQuery[sym__ajaxSettings_].xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery[sym__support_][sym__ajax_] ) {

    jQuery[sym__ajaxTransport_](function( s ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !s[sym__crossDomain_] || jQuery[sym__support_].cors ) {

            var callback;

            return {
                send: function( headers, complete ) {

                    // Get a new xhr
                    var handle, i,
                        xhr = s.xhr();

                    // Open the socket
                    // Passing null username, generates a login popup on Opera (#2865)
                    if ( s.username ) {
                        xhr.open( s[sym__type_], s[sym__url_], s[sym__async_], s.username, s[sym__password_] );
                    } else {
                        xhr.open( s[sym__type_], s[sym__url_], s[sym__async_] );
                    }

                    // Apply custom fields if provided
                    if ( s[sym__xhrFields_] ) {
                        for ( i in s[sym__xhrFields_] ) {
                            xhr[ i ] = s[sym__xhrFields_][ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( s[sym__mimeType_] && xhr[sym__overrideMimeType_] ) {
                        xhr[sym__overrideMimeType_]( s[sym__mimeType_] );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !s[sym__crossDomain_] && !headers["X-Requested-With"] ) {
                        headers[ "X-Requested-With" ] = sym__XMLHttpRequest_;
                    }

                    // Need an extra try/catch for cross domain requests in Firefox 3
                    try {
                        for ( i in headers ) {
                            xhr[sym__setRequestHeader_]( i, headers[ i ] );
                        }
                    } catch( _ ) {}

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send( ( s[sym__hasContent_] && s[sym__data_] ) || sym__g_null_ );

                    // Listener
                    callback = function( _, isAbort ) {

                        var status,
                            statusText,
                            responseHeaders,
                            responses,
                            xml;

                        // Firefox throws exceptions when accessing properties
                        // of an xhr when a network error occurred
                        // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                        try {

                            // Was never called and is aborted or complete
                            if ( callback && ( isAbort || xhr[sym__readyState_] === 4 ) ) {

                                // Only called once
                                callback = undefined;

                                // Do not keep as active anymore
                                if ( handle ) {
                                    xhr[sym__onreadystatechange_] = jQuery.noop;
                                    if ( xhrOnUnloadAbort ) {
                                        delete xhrCallbacks[ handle ];
                                    }
                                }

                                // If it's an abort
                                if ( isAbort ) {
                                    // Abort it manually if needed
                                    if ( xhr[sym__readyState_] !== 4 ) {
                                        xhr[sym__abort_]();
                                    }
                                } else {
                                    status = xhr[sym__status_];
                                    responseHeaders = xhr.getAllResponseHeaders();
                                    responses = {};
                                    xml = xhr[sym__responseXML_];

                                    // Construct response list
                                    if ( xml && xml[sym__documentElement_] /* #4958 */ ) {
                                        responses.xml = xml;
                                    }

                                    // When requesting binary data, IE6-9 will throw an exception
                                    // on any attempt to access responseText (#11426)
                                    try {
                                        responses[sym__text_] = xhr[sym__responseText_];
                                    } catch( e ) {
                                    }

                                    // Firefox throws an exception when accessing
                                    // statusText for faulty cross-domain requests
                                    try {
                                        statusText = xhr[sym__statusText_];
                                    } catch( e ) {
                                        // We normalize with Webkit giving an empty statusText
                                        statusText = "";
                                    }

                                    // Filter status for non standard behaviors

                                    // If the request is local and we have data: assume a success
                                    // (success with no data won't get notified, that's the best we
                                    // can do given current implementations)
                                    if ( !status && s.isLocal && !s[sym__crossDomain_] ) {
                                        status = responses[sym__text_] ? 200 : 404;
                                    // IE - #1450: sometimes returns 1223 when it should be 204
                                    } else if ( status === 1223 ) {
                                        status = 204;
                                    }
                                }
                            }
                        } catch( firefoxAccessException ) {
                            if ( !isAbort ) {
                                complete( -1, firefoxAccessException );
                            }
                        }

                        // Call complete if needed
                        if ( responses ) {
                            complete( status, statusText, responses, responseHeaders );
                        }
                    };

                    if ( !s[sym__async_] ) {
                        // if we're in sync mode we fire the callback
                        callback();
                    } else if ( xhr[sym__readyState_] === 4 ) {
                        // (IE6 & IE7) if it's in cache and has been
                        // retrieved directly we need to fire the callback
                        setTimeout( callback, 0 );
                    } else {
                        handle = ++xhrId;
                        if ( xhrOnUnloadAbort ) {
                            // Create the active xhrs callbacks list if needed
                            // and attach the unload handler
                            if ( !xhrCallbacks ) {
                                xhrCallbacks = {};
                                jQuery( sym__g_window_ ).unload( xhrOnUnloadAbort );
                            }
                            // Add to list of active xhrs callbacks
                            xhrCallbacks[ handle ] = callback;
                        }
                        xhr[sym__onreadystatechange_] = callback;
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback(0,1);
                    }
                }
            };
        }
    });
}
var fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        "*": [function( prop, value ) {
            var end, unit,
                tween = this[sym__createTween_]( prop, value ),
                parts = rfxnum[sym__exec_]( value ),
                target = tween.cur(),
                start = +target || 0,
                scale = 1,
                maxIterations = 20;

            if ( parts ) {
                end = +parts[2];
                unit = parts[3] || ( jQuery[sym__cssNumber_][ prop ] ? "" : sym__px_ );

                // We need to compute starting value
                if ( unit !== sym__px_ && start ) {
                    // Iteratively approximate from a nonzero starting point
                    // Prefer the current property, because this process will be trivial if it uses the same units
                    // Fallback to end or a simple constant
                    start = jQuery[sym__css_]( tween[sym__elem_], prop, sym__g_true_ ) || end || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*
                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery[sym__style_]( tween[sym__elem_], prop, start + unit );

                    // Update scale, tolerating zero or NaN from tween.cur()
                    // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                    } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                }

                tween.unit = unit;
                tween[sym__start_] = start;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
            }
            return tween;
        }]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    }, 0 );
    return ( fxNow = jQuery[sym__now_]() );
}

function createTweens( animation, props ) {
    jQuery[sym__each_]( props, function( prop, value ) {
        var collection = ( tweeners[ prop ] || [] )[sym__concat_]( tweeners[ "*" ] ),
            index = 0,
            length = collection[sym__length_];
        for ( ; index < length; index++ ) {
            if ( collection[ index ][sym__call_]( animation, prop, value ) ) {

                // we're done with this property
                return;
            }
        }
    });
}

function Animation( elem, properties, options ) {
    var result,
        index = 0,
        tweenerIndex = 0,
        length = animationPrefilters[sym__length_],
        deferred = jQuery[sym__Deferred_]()[sym__always_]( function() {
            // don't match elem in the :animated selector
            delete tick[sym__elem_];
        }),
        tick = function() {
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation[sym__duration_] - currentTime ),
                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation[sym__duration_] || 0,
                percent = 1 - temp,
                index = 0,
                length = animation[sym__tweens_][sym__length_];

            for ( ; index < length ; index++ ) {
                animation[sym__tweens_][ index ].run( percent );
            }

            deferred[sym__notifyWith_]( elem, [ animation, percent, remaining ]);

            if ( percent < 1 && length ) {
                return remaining;
            } else {
                deferred[sym__resolveWith_]( elem, [ animation ] );
                return sym__g_false_;
            }
        },
        animation = deferred[sym__promise_]({
            elem: elem,
            props: jQuery[sym__extend_]( {}, properties ),
            opts: jQuery[sym__extend_]( sym__g_true_, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options[sym__duration_],
            tweens: [],
            createTween: function( prop, end, easing ) {
                var tween = jQuery.Tween( elem, animation[sym__opts_], prop, end,
                        animation[sym__opts_][sym__specialEasing_][ prop ] || animation[sym__opts_][sym__easing_] );
                animation[sym__tweens_][sym__push_]( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation[sym__tweens_][sym__length_] : 0;

                for ( ; index < length ; index++ ) {
                    animation[sym__tweens_][ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred[sym__resolveWith_]( elem, [ animation, gotoEnd ] );
                } else {
                    deferred[sym__rejectWith_]( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation[sym__props_];

    propFilter( props, animation[sym__opts_][sym__specialEasing_] );

    for ( ; index < length ; index++ ) {
        result = animationPrefilters[ index ][sym__call_]( animation, elem, props, animation[sym__opts_] );
        if ( result ) {
            return result;
        }
    }

    createTweens( animation, props );

    if ( jQuery[sym__isFunction_]( animation[sym__opts_][sym__start_] ) ) {
        animation[sym__opts_][sym__start_][sym__call_]( elem, animation );
    }

    jQuery[sym__fx_].timer(
        jQuery[sym__extend_]( tick, {
            anim: animation,
            queue: animation[sym__opts_][sym__queue_],
            elem: elem
        })
    );

    // attach callbacks from options
    return animation[sym__progress_]( animation[sym__opts_][sym__progress_] )
        [sym__done_]( animation[sym__opts_][sym__done_], animation[sym__opts_][sym__complete_] )
        [sym__fail_]( animation[sym__opts_][sym__fail_] )
        [sym__always_]( animation[sym__opts_][sym__always_] );
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery[sym__camelCase_]( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery[sym__isArray_]( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery[sym__cssHooks_][ name ];
        if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

jQuery.Animation = jQuery[sym__extend_]( Animation, {

    tweener: function( props, callback ) {
        if ( jQuery[sym__isFunction_]( props ) ) {
            callback = props;
            props = [ "*" ];
        } else {
            props = props[sym__split_](" ");
        }

        var prop,
            index = 0,
            length = props[sym__length_];

        for ( ; index < length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ][sym__unshift_]( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters[sym__unshift_]( callback );
        } else {
            animationPrefilters[sym__push_]( callback );
        }
    }
});

function defaultPrefilter( elem, props, opts ) {
    var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
        anim = this,
        style = elem[sym__style_],
        orig = {},
        handled = [],
        hidden = elem[sym__nodeType_] && isHidden( elem );

    // handle queue: false promises
    if ( !opts[sym__queue_] ) {
        hooks = jQuery._queueHooks( elem, sym__fx_ );
        if ( hooks[sym__unqueued_] == sym__g_null_ ) {
            hooks[sym__unqueued_] = 0;
            oldfire = hooks[sym__empty_][sym__fire_];
            hooks[sym__empty_][sym__fire_] = function() {
                if ( !hooks[sym__unqueued_] ) {
                    oldfire();
                }
            };
        }
        hooks[sym__unqueued_]++;

        anim[sym__always_](function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim[sym__always_](function() {
                hooks[sym__unqueued_]--;
                if ( !jQuery[sym__queue_]( elem, sym__fx_ )[sym__length_] ) {
                    hooks[sym__empty_][sym__fire_]();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem[sym__nodeType_] === 1 && ( sym__height_ in props || sym__width_ in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts[sym__overflow_] = [ style[sym__overflow_], style[sym__overflowX_], style[sym__overflowY_] ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        if ( jQuery[sym__css_]( elem, sym__display_ ) === "inline" &&
                jQuery[sym__css_]( elem, "float" ) === sym__none_ ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !jQuery[sym__support_][sym__inlineBlockNeedsLayout_] || css_defaultDisplay( elem[sym__nodeName_] ) === "inline" ) {
                style[sym__display_] = "inline-block";

            } else {
                style[sym__zoom_] = 1;
            }
        }
    }

    if ( opts[sym__overflow_] ) {
        style[sym__overflow_] = sym__hidden_;
        if ( !jQuery[sym__support_][sym__shrinkWrapBlocks_] ) {
            anim[sym__done_](function() {
                style[sym__overflow_] = opts[sym__overflow_][ 0 ];
                style[sym__overflowX_] = opts[sym__overflow_][ 1 ];
                style[sym__overflowY_] = opts[sym__overflow_][ 2 ];
            });
        }
    }


    // show/hide pass
    for ( index in props ) {
        value = props[ index ];
        if ( rfxtypes[sym__exec_]( value ) ) {
            delete props[ index ];
            toggle = toggle || value === sym__toggle_;
            if ( value === ( hidden ? "hide" : sym__show_ ) ) {
                continue;
            }
            handled[sym__push_]( index );
        }
    }

    length = handled[sym__length_];
    if ( length ) {
        dataShow = jQuery._data( elem, sym__fxshow_ ) || jQuery._data( elem, sym__fxshow_, {} );
        if ( sym__hidden_ in dataShow ) {
            hidden = dataShow[sym__hidden_];
        }

        // store state if its toggle - enables .stop().toggle() to "reverse"
        if ( toggle ) {
            dataShow[sym__hidden_] = !hidden;
        }
        if ( hidden ) {
            jQuery( elem )[sym__show_]();
        } else {
            anim[sym__done_](function() {
                jQuery( elem )[sym__hide_]();
            });
        }
        anim[sym__done_](function() {
            var prop;
            jQuery[sym__removeData_]( elem, sym__fxshow_, sym__g_true_ );
            for ( prop in orig ) {
                jQuery[sym__style_]( elem, prop, orig[ prop ] );
            }
        });
        for ( index = 0 ; index < length ; index++ ) {
            prop = handled[ index ];
            tween = anim[sym__createTween_]( prop, hidden ? dataShow[ prop ] : 0 );
            orig[ prop ] = dataShow[ prop ] || jQuery[sym__style_]( elem, prop );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween[sym__start_];
                if ( hidden ) {
                    tween.end = tween[sym__start_];
                    tween[sym__start_] = prop === sym__width_ || prop === sym__height_ ? 1 : 0;
                }
            }
        }
    }
}

function Tween( elem, options, prop, end, easing ) {
    return new Tween[sym__prototype_][sym__init_]( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween[sym__prototype_] = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this[sym__elem_] = elem;
        this[sym__prop_] = prop;
        this[sym__easing_] = easing || "swing";
        this[sym__options_] = options;
        this[sym__start_] = this[sym__now_] = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery[sym__cssNumber_][ prop ] ? "" : sym__px_ );
    },
    cur: function() {
        var hooks = Tween[sym__propHooks_][ this[sym__prop_] ];

        return hooks && hooks[sym__get_] ?
            hooks[sym__get_]( this ) :
            Tween[sym__propHooks_]._default[sym__get_]( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween[sym__propHooks_][ this[sym__prop_] ];

        if ( this[sym__options_][sym__duration_] ) {
            this.pos = eased = jQuery[sym__easing_][ this[sym__easing_] ](
                percent, this[sym__options_][sym__duration_] * percent, 0, 1, this[sym__options_][sym__duration_]
            );
        } else {
            this.pos = eased = percent;
        }
        this[sym__now_] = ( this.end - this[sym__start_] ) * eased + this[sym__start_];

        if ( this[sym__options_][sym__step_] ) {
            this[sym__options_][sym__step_][sym__call_]( this[sym__elem_], this[sym__now_], this );
        }

        if ( hooks && hooks[sym__set_] ) {
            hooks[sym__set_]( this );
        } else {
            Tween[sym__propHooks_]._default[sym__set_]( this );
        }
        return this;
    }
};

Tween[sym__prototype_][sym__init_][sym__prototype_] = Tween[sym__prototype_];

Tween[sym__propHooks_] = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween[sym__elem_][ tween[sym__prop_] ] != sym__g_null_ &&
                (!tween[sym__elem_][sym__style_] || tween[sym__elem_][sym__style_][ tween[sym__prop_] ] == sym__g_null_) ) {
                return tween[sym__elem_][ tween[sym__prop_] ];
            }

            // passing any value as a 4th parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as "10px" are parsed to Float.
            // complex values such as "rotate(1rad)" are returned as is.
            result = jQuery[sym__css_]( tween[sym__elem_], tween[sym__prop_], sym__g_false_, "" );
            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === sym__auto_ ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery[sym__fx_][sym__step_][ tween[sym__prop_] ] ) {
                jQuery[sym__fx_][sym__step_][ tween[sym__prop_] ]( tween );
            } else if ( tween[sym__elem_][sym__style_] && ( tween[sym__elem_][sym__style_][ jQuery[sym__cssProps_][ tween[sym__prop_] ] ] != sym__g_null_ || jQuery[sym__cssHooks_][ tween[sym__prop_] ] ) ) {
                jQuery[sym__style_]( tween[sym__elem_], tween[sym__prop_], tween[sym__now_] + tween.unit );
            } else {
                tween[sym__elem_][ tween[sym__prop_] ] = tween[sym__now_];
            }
        }
    }
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween[sym__propHooks_][sym__scrollTop_] = Tween[sym__propHooks_][sym__scrollLeft_] = {
    set: function( tween ) {
        if ( tween[sym__elem_][sym__nodeType_] && tween[sym__elem_][sym__parentNode_] ) {
            tween[sym__elem_][ tween[sym__prop_] ] = tween[sym__now_];
        }
    }
};

jQuery[sym__each_]([ sym__toggle_, sym__show_, sym__hide_ ], function( i, name ) {
    var cssFn = jQuery[sym__fn_][ name ];
    jQuery[sym__fn_][ name ] = function( speed, easing, callback ) {
        return speed == sym__g_null_ || typeof speed === sym__boolean_ ||
            // special check for .toggle( handler, handler, ... )
            ( !i && jQuery[sym__isFunction_]( speed ) && jQuery[sym__isFunction_]( easing ) ) ?
            cssFn[sym__apply_]( this, arguments ) :
            this[sym__animate_]( genFx( name, sym__g_true_ ), speed, easing, callback );
    };
});

jQuery[sym__fn_][sym__extend_]({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this[sym__filter_]( isHidden )[sym__css_]( sym__opacity_, 0 )[sym__show_]()

            // animate to the value specified
            .end()[sym__animate_]({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery[sym__isEmptyObject_]( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation( this, jQuery[sym__extend_]( {}, prop ), optall );

                // Empty animations resolve immediately
                if ( empty ) {
                    anim[sym__stop_]( sym__g_true_ );
                }
            };

        return empty || optall[sym__queue_] === sym__g_false_ ?
            this[sym__each_]( doAnimation ) :
            this[sym__queue_]( optall[sym__queue_], doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks[sym__stop_];
            delete hooks[sym__stop_];
            stop( gotoEnd );
        };

        if ( typeof type !== sym__string_ ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue && type !== sym__g_false_ ) {
            this[sym__queue_]( type || sym__fx_, [] );
        }

        return this[sym__each_](function() {
            var dequeue = sym__g_true_,
                index = type != sym__g_null_ && type + sym__queueHooks_,
                timers = jQuery[sym__timers_],
                data = jQuery._data( this );

            if ( index ) {
                if ( data[ index ] && data[ index ][sym__stop_] ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] && data[ index ][sym__stop_] && rrun[sym__test_]( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers[sym__length_]; index--; ) {
                if ( timers[ index ][sym__elem_] === this && (type == sym__g_null_ || timers[ index ][sym__queue_] === type) ) {
                    timers[ index ].anim[sym__stop_]( gotoEnd );
                    dequeue = sym__g_false_;
                    timers[sym__splice_]( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn't forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery[sym__dequeue_]( this, type );
            }
        });
    }
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth? 1 : 0;
    for( ; i < 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ sym__margin_ + which ] = attrs[ sym__padding_ + which ] = type;
    }

    if ( includeWidth ) {
        attrs[sym__opacity_] = attrs[sym__width_] = type;
    }

    return attrs;
}

// Generate shortcuts for custom animations
jQuery[sym__each_]({
    slideDown: genFx(sym__show_),
    slideUp: genFx(sym__hide_),
    slideToggle: genFx(sym__toggle_),
    fadeIn: { opacity: sym__show_ },
    fadeOut: { opacity: sym__hide_ },
    fadeToggle: { opacity: sym__toggle_ }
}, function( name, props ) {
    jQuery[sym__fn_][ name ] = function( speed, easing, callback ) {
        return this[sym__animate_]( props, speed, easing, callback );
    };
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === sym__object_ ? jQuery[sym__extend_]( {}, speed ) : {
        complete: fn || !fn && easing ||
            jQuery[sym__isFunction_]( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery[sym__isFunction_]( easing ) && easing
    };

    opt[sym__duration_] = jQuery[sym__fx_][sym__off_] ? 0 : typeof opt[sym__duration_] === sym__number_ ? opt[sym__duration_] :
        opt[sym__duration_] in jQuery[sym__fx_][sym__speeds_] ? jQuery[sym__fx_][sym__speeds_][ opt[sym__duration_] ] : jQuery[sym__fx_][sym__speeds_]._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt[sym__queue_] == sym__g_null_ || opt[sym__queue_] === sym__g_true_ ) {
        opt[sym__queue_] = sym__fx_;
    }

    // Queueing
    opt.old = opt[sym__complete_];

    opt[sym__complete_] = function() {
        if ( jQuery[sym__isFunction_]( opt.old ) ) {
            opt.old[sym__call_]( this );
        }

        if ( opt[sym__queue_] ) {
            jQuery[sym__dequeue_]( this, opt[sym__queue_] );
        }
    };

    return opt;
};

jQuery[sym__easing_] = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p*Math.PI ) / 2;
    }
};

jQuery[sym__timers_] = [];
jQuery[sym__fx_] = Tween[sym__prototype_][sym__init_];
jQuery[sym__fx_].tick = function() {
    var timer,
        timers = jQuery[sym__timers_],
        i = 0;

    fxNow = jQuery[sym__now_]();

    for ( ; i < timers[sym__length_]; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers[sym__splice_]( i--, 1 );
        }
    }

    if ( !timers[sym__length_] ) {
        jQuery[sym__fx_][sym__stop_]();
    }
    fxNow = undefined;
};

jQuery[sym__fx_].timer = function( timer ) {
    if ( timer() && jQuery[sym__timers_][sym__push_]( timer ) && !timerId ) {
        timerId = setInterval( jQuery[sym__fx_].tick, jQuery[sym__fx_].interval );
    }
};

jQuery[sym__fx_].interval = 13;

jQuery[sym__fx_][sym__stop_] = function() {
    clearInterval( timerId );
    timerId = sym__g_null_;
};

jQuery[sym__fx_][sym__speeds_] = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};

// Back Compat <1.8 extension point
jQuery[sym__fx_][sym__step_] = {};

if ( jQuery[sym__expr_] && jQuery[sym__expr_][sym__filters_] ) {
    jQuery[sym__expr_][sym__filters_].animated = function( elem ) {
        return jQuery[sym__grep_](jQuery[sym__timers_], function( fn ) {
            return elem === fn[sym__elem_];
        })[sym__length_];
    };
}
var rroot = /^(?:body|html)$/i;

jQuery[sym__fn_][sym__offset_] = function( options ) {
    if ( arguments[sym__length_] ) {
        return options === undefined ?
            this :
            this[sym__each_](function( i ) {
                jQuery[sym__offset_].setOffset( this, options, i );
            });
    }

    var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
        box = { top: 0, left: 0 },
        elem = this[ 0 ],
        doc = elem && elem[sym__ownerDocument_];

    if ( !doc ) {
        return;
    }

    if ( (body = doc[sym__body_]) === elem ) {
        return jQuery[sym__offset_].bodyOffset( elem );
    }

    docElem = doc[sym__documentElement_];

    // Make sure it's not a disconnected DOM node
    if ( !jQuery[sym__contains_]( docElem, elem ) ) {
        return box;
    }

    // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)
    if ( typeof elem[sym__getBoundingClientRect_] !== sym__undefined_ ) {
        box = elem[sym__getBoundingClientRect_]();
    }
    win = getWindow( doc );
    clientTop  = docElem[sym__clientTop_]  || body[sym__clientTop_]  || 0;
    clientLeft = docElem[sym__clientLeft_] || body[sym__clientLeft_] || 0;
    scrollTop  = win[sym__pageYOffset_] || docElem[sym__scrollTop_];
    scrollLeft = win[sym__pageXOffset_] || docElem[sym__scrollLeft_];
    return {
        top: box[sym__top_]  + scrollTop  - clientTop,
        left: box[sym__left_] + scrollLeft - clientLeft
    };
};

jQuery[sym__offset_] = {

    bodyOffset: function( body ) {
        var top = body[sym__offsetTop_],
            left = body.offsetLeft;

        if ( jQuery[sym__support_][sym__doesNotIncludeMarginInBodyOffset_] ) {
            top  += parseFloat( jQuery[sym__css_](body, sym__marginTop_) ) || 0;
            left += parseFloat( jQuery[sym__css_](body, sym__marginLeft_) ) || 0;
        }

        return { top: top, left: left };
    },

    setOffset: function( elem, options, i ) {
        var position = jQuery[sym__css_]( elem, sym__position_ );

        // set position first, in-case top/left are set even on static elem
        if ( position === "static" ) {
            elem[sym__style_][sym__position_] = sym__relative_;
        }

        var curElem = jQuery( elem ),
            curOffset = curElem[sym__offset_](),
            curCSSTop = jQuery[sym__css_]( elem, sym__top_ ),
            curCSSLeft = jQuery[sym__css_]( elem, sym__left_ ),
            calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery[sym__inArray_](sym__auto_, [curCSSTop, curCSSLeft]) > -1,
            props = {}, curPosition = {}, curTop, curLeft;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem[sym__position_]();
            curTop = curPosition[sym__top_];
            curLeft = curPosition[sym__left_];
        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery[sym__isFunction_]( options ) ) {
            options = options[sym__call_]( elem, i, curOffset );
        }

        if ( options[sym__top_] != sym__g_null_ ) {
            props[sym__top_] = ( options[sym__top_] - curOffset[sym__top_] ) + curTop;
        }
        if ( options[sym__left_] != sym__g_null_ ) {
            props[sym__left_] = ( options[sym__left_] - curOffset[sym__left_] ) + curLeft;
        }

        if ( "using" in options ) {
            options.using[sym__call_]( elem, props );
        } else {
            curElem[sym__css_]( props );
        }
    }
};


jQuery[sym__fn_][sym__extend_]({

    position: function() {
        if ( !this[0] ) {
            return;
        }

        var elem = this[0],

        // Get *real* offsetParent
        offsetParent = this[sym__offsetParent_](),

        // Get correct offsets
        offset       = this[sym__offset_](),
        parentOffset = rroot[sym__test_](offsetParent[0][sym__nodeName_]) ? { top: 0, left: 0 } : offsetParent[sym__offset_]();

        // Subtract element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        offset[sym__top_]  -= parseFloat( jQuery[sym__css_](elem, sym__marginTop_) ) || 0;
        offset[sym__left_] -= parseFloat( jQuery[sym__css_](elem, sym__marginLeft_) ) || 0;

        // Add offsetParent borders
        parentOffset[sym__top_]  += parseFloat( jQuery[sym__css_](offsetParent[0], "borderTopWidth") ) || 0;
        parentOffset[sym__left_] += parseFloat( jQuery[sym__css_](offsetParent[0], "borderLeftWidth") ) || 0;

        // Subtract the two offsets
        return {
            top:  offset[sym__top_]  - parentOffset[sym__top_],
            left: offset[sym__left_] - parentOffset[sym__left_]
        };
    },

    offsetParent: function() {
        return this[sym__map_](function() {
            var offsetParent = this[sym__offsetParent_] || document[sym__body_];
            while ( offsetParent && (!rroot[sym__test_](offsetParent[sym__nodeName_]) && jQuery[sym__css_](offsetParent, sym__position_) === "static") ) {
                offsetParent = offsetParent[sym__offsetParent_];
            }
            return offsetParent || document[sym__body_];
        });
    }
});


// Create scrollLeft and scrollTop methods
jQuery[sym__each_]( {scrollLeft: sym__pageXOffset_, scrollTop: sym__pageYOffset_}, function( method, prop ) {
    var top = /Y/[sym__test_]( prop );

    jQuery[sym__fn_][ method ] = function( val ) {
        return jQuery[sym__access_]( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? (prop in win) ? win[ prop ] :
                    win[sym__document_][sym__documentElement_][ method ] :
                    elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : jQuery( win )[sym__scrollLeft_](),
                     top ? val : jQuery( win )[sym__scrollTop_]()
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments[sym__length_], sym__g_null_ );
    };
});

function getWindow( elem ) {
    return jQuery[sym__isWindow_]( elem ) ?
        elem :
        elem[sym__nodeType_] === 9 ?
            elem[sym__defaultView_] || elem[sym__parentWindow_] :
            sym__g_false_;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery[sym__each_]( { Height: sym__height_, Width: sym__width_ }, function( name, type ) {
    jQuery[sym__each_]( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery[sym__fn_][ funcName ] = function( margin, value ) {
            var chainable = arguments[sym__length_] && ( defaultExtra || typeof margin !== sym__boolean_ ),
                extra = defaultExtra || ( margin === sym__g_true_ || value === sym__g_true_ ? "margin" : sym__border_ );

            return jQuery[sym__access_]( this, function( elem, type, value ) {
                var doc;

                if ( jQuery[sym__isWindow_]( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem[sym__document_][sym__documentElement_][ "client" + name ];
                }

                // Get document width or height
                if ( elem[sym__nodeType_] === 9 ) {
                    doc = elem[sym__documentElement_];

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                    return Math.max(
                        elem[sym__body_][ "scroll" + name ], doc[ "scroll" + name ],
                        elem[sym__body_][ sym__offset_ + name ], doc[ sym__offset_ + name ],
                        doc[ "client" + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery[sym__css_]( elem, type, value, extra ) :

                    // Set width or height on the element
                    jQuery[sym__style_]( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, sym__g_null_ );
        };
    });
});
// Expose jQuery to the global object
sym__g_window_[sym__jQuery_] = sym__g_window_.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === sym__function_ && define.amd && define.amd[sym__jQuery_] ) {
    define( sym__jquery_, [], function () { return jQuery; } );
}

})( sym__g_window_ );})(this, null, !1, !0, "PSEUDO", "fx", "form", "pixelPosition", "deletedIds", "cssText", "makeArray", "pseudos", "domManip", "resolveWith", "unique", "extend", "fail", "contentWindow", "pageXOffset", "dispatch", "inprogress", "dataTypes", "isPropagationStopped", "ajaxTransport", "toggle", "nextSibling", "htmlSerialize", "traditional", "crossDomain", "mimeType", "removeAttr", "fixHooks", "offsetHeight", "dir", "doesNotIncludeMarginInBodyOffset", "unqueued", "overflow", "reliableMarginRight", "expando", "access", "concat", "getElementsByTagName", "removeEvent", "delegateTarget", "prop", "ifModified", "beforeSend", "left", "remove", "substr", "display", "jQuery", "grep", "cssFloat", "accepts", "toLowerCase", "id", "cleanData", "runtimeStyle", "abort", "currentStyle", "data", "setFilters", "contains", "jquery", "overrideMimeType", "props", "shift", "olddisplay", "type", "support", "div", "object", "previousSibling", "trigger", "scrollTop", "add", "buildFragment", "bindType", "status", "needsContext", "submit", "sizset", "overflowY", "lastChild", "get", "parsedAttrs", "context", "guid", "option", "leadingWhitespace", "global", "prevObject", "isTrigger", "border", "parseJSON", "auto", "removeClass", "relatedTarget", "cssProps", "fireWith", "nodeName", "complete", "delegateType", "attrHooks", "content", "string", "filters", "getBoundingClientRect", "on", "map", "childNodes", "timeout", "marginRight", "deleteExpando", "change", "marginTop", "triggerHandler", "selectors", "handle", "top", "queue", "inlineBlockNeedsLayout", "insertBefore", "width", "preDispatch", "number", "isFunction", "body", "html", "fragments", "error", "ActiveXObject", "clearAttributes", "disable", "isWindow", "matches", "namespace", "constructor", "fireEvent", "style", "triggered", "ajax", "now", "radioValue", "onbeforeunload", "shrinkWrapBlocks", "indexOf", "cache", "getElementById", "XMLHttpRequest", "postDispatch", "checkbox", "test", "document", "CHILD", "isEmptyObject", "parentNode", "pageYOffset", "isPlainObject", "step", "propFix", "clone", "scriptCharset", "prototype", "param", "exec", "show", "createElement", "clientLeft", "specialEasing", "duration", "boxSizingReliable", "statusText", "event", "lastToggle", "DOMContentLoaded", "valHooks", "globalEval", "createTween", "timeStamp", "append", "jsonpCallback", "getElementsByClassName", "expr", "call", "checkClone", "getPreventDefault", "speeds", "Callbacks", "handler", "querySelectorAll", "mergeAttributes", "selected", "replaceWith", "acceptData", "which", "returnValue", "camelCase", "init", "target", "queueHooks", "password", "propHooks", "notifyWith", "opts", "easing", "always", "relative", "each", "trim", "Deferred", "name", "className", "nodeValue", "specified", "hide", "promise", "start", "cacheable", "css", "getAttribute", "enctype", "outerHTML", "delegateCount", "boolean", "opacity", "uniqueSort", "maxWidth", "selectedIndex", "unshift", "cloneNode", "appendChecked", "removeAttribute", "CLASS", "isImmediatePropagationStopped", "appendChild", "progress", "boxSizing", "height", "getElementsByName", "isXMLDoc", "index", "click", "length", "sort", "events", "ownerDocument", "sourceIndex", "defaultView", "false", "ajaxSettings", "async", "off", "noCloneEvent", "slice", "jsonp", "special", "activeElement", "href", "addEventListener", "animate", "origType", "exclusive", "split", "changeData", "removeChild", "selector", "tbody", "xhrFields", "value", "active", "dataFilter", "hasOwnProperty", "replace", "push", "setAttribute", "rejectWith", "ready", "defaultValue", "offsetParent", "readyWait", "stopPropagation", "isSimulated", "position", "readyState", "pushStack", "optDisabled", "fxshow", "isReady", "noCloneChecked", "isArray", "reliableHiddenOffsets", "fire", "parentWindow", "fn", "contentType", "Event", "zoom", "cssNumber", "contentDocument", "splice", "ajaxSetup", "block", "hidden", "button", "reject", "input", "attachEvent", "handleObj", "charAt", "isNumeric", "responseXML", "removeData", "toUpperCase", "offsetTop", "url", "preventDefault", "innerHTML", "parsererror", "setRequestHeader", "responseText", "join", "onclick", "attributes", "wrapAll", "getComputedStyle", "result", "none", "options", "function", "textContent", "find", "attr", "statusCode", "clientTop", "text", "converters", "set", "padding", "getAttributeNode", "filter", "cssHooks", "documentElement", "radio", "dequeue", "simulate", "html5Clone", "firstChild", "elem", "done", "ajaxPrefilter", "scrollLeft", "browser", "matchesSelector", "marginLeft", "undefined", "before", "timers", "hasContent", "success", "clean", "removeEventListener", "checked", "compareDocumentPosition", "lastModified", "px", "onreadystatechange", "nodeType", "disabled", "minWidth", "fragment", "Width", "apply", "merge", "tweens", "empty", "offset", "isDefaultPrevented", "first", "script", "stop", "defaultChecked", "offsetWidth", "createDocumentFragment", "getResponseHeader", "inArray", "detachEvent", "overflowX", "originalEvent", "createTextNode", "onload", "margin");
